<!DOCTYPE html>
<html lang="en">
<head>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src='//whephiwums.com/sdk.js' data-zone='9302441' data-sdk='show_9302441'></script>    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <!-- Meta-tags to force portrait orientation -->
    <meta name="screen-orientation" content="portrait">
    <meta name="x5-orientation" content="portrait">
    <meta name="msapplication-orientation" content="portrait">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>TiDash</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script 
        async 
        src="https://tganalytics.xyz/index.js" 
        onload="initAnalytics()" 
        type="text/javascript"
    ></script>
    <script>
        function initAnalytics() {
            window.telegramAnalytics.init({
                token: 'eyJhcHBfbmFtZSI6InRpZGFzaF9ib3RfYW5hbHl0aWNzIiwiYXBwX3VybCI6Imh0dHBzOi8vdC5tZS9UaURhc2hfYm90IiwiYXBwX2RvbWFpbiI6Imh0dHBzOi8vc29mdHMubGlmZSJ9!3anwT9jNgSCL5VSFAecFl5wOJehXzKxhcFo0CiCNVoo=', // SDK Auth token received via @DataChief_bot
                appName: 'tidash_bot_analytics', // The analytics identifier you entered in @DataChief_bot
            });
        }
</script>


    <!-- Preloading sounds -->
    <audio id="userTapSound" src="sounds/UserTap.mp3" preload="auto"></audio>
    <audio id="successSound" src="sounds/Success.mp3" preload="auto"></audio>
    <audio id="gameOverSound" src="sounds/Termine.mp3" preload="auto"></audio>
    <audio id="showScoreSound" src="sounds/Show_GameOver.mp3" preload="auto"></audio>
    <audio id="borderTouchSound" src="sounds/BorderTouch.mp3" preload="auto"></audio>
    <!-- Audio element for background music -->
    <audio id="backgroundMusic" preload="auto"></audio>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');
        
        body {
            font-family: 'Orbitron', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #0A0A0A;
            /* overflow: hidden;  <-- removed to allow settings scroll on Android */
            touch-action: manipulation;
            position: relative;
        }
        
        .container {
            position: relative;
            width: 90%;
            max-width: 400px;
            height: 90vh;
            max-height: 800px;
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
            background-color: #121212;
            border: 10px solid #0A0A0A;
            margin: 20px auto;
        }
        
        #game-canvas {
            background-color: #121212;
            background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.3));
            display: block;
            width: 100%;
            height: 100%;
            position: relative;
            z-index: 1;
        }
        
        #game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #121212;
            background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.3));
            display: none;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            color: white;
            z-index: 10;
            font-family: 'Orbitron', sans-serif;
            opacity: 0;
            transition: opacity 1s ease-in-out;
            padding-top: 0;
        }
        
        #game-over.visible {
            opacity: 1;
        }
        
        #score-display {
            font-size: 4rem;
            margin-bottom: 10px;
            color: #00FF9D;
            font-weight: bold;
        }
        
        #best-score {
            font-size: 1.8rem;
            margin-bottom: 10px;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        #season-score {
            font-size: 1.3rem;
            margin-bottom: 10px;
            color: #00FF9D;
            text-transform: uppercase;
            letter-spacing: 1px;
            display: none !important;
            font-weight: bold;
        }
        
        .button-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        #home-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 0;
            box-sizing: border-box;
            pointer-events: auto;
            z-index: 5;
            background-color: rgba(0, 0, 0, 0.3);
        }
        
        /* Style for the gift button */
        #gift-button {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 10;
            transition: all 0.3s ease;
        }
        
        
        .gift-icon {
            width: 24px;
            height: 24px;
            object-fit: contain;
        }
        
        /* Style for the red notification badge */
        .notification-badge {
            position: absolute;
            top: 0px;
            right: 0px;
            width: 10px;
            height: 10px;
            background-color: #FF3B30;
            border-radius: 50%;
            border: 1px solid rgba(0, 0, 0, 0.5);
        }
        
        /* Style for the season container */
        .season-container {
            position: relative;
            width: 200px;
            height: 55px;
            margin: 0 auto 70px auto;
            margin-top: -90px;
            background-image: url('ressources/back_season.jpg');
            background-size: cover;
            border-radius: 20px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0, 255, 157, 0.7);
            z-index: 6;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.18);
            transition: all 0.3s ease;
        }
        
        .season-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(0,255,157,0.3) 0%, rgba(0,0,0,0) 50%);
            z-index: -1;
        }
        
        .season-prize {
            font-size: 0.8rem;
            font-weight: 600;
            margin-bottom: 2px;
            font-family: 'Orbitron', sans-serif;
            text-shadow: 0 0 10px rgba(0, 255, 157, 0.8);
            letter-spacing: 0.5px;
        }
        
        .season-name {
            font-size: 1rem;
            font-weight: 700;
            text-transform: uppercase;
            font-family: 'Orbitron', sans-serif;
            background: linear-gradient(90deg, #FFFFFF 0%, #00FF9D 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            color: transparent;
            letter-spacing: 1px;
        }
        
        /* Style for particles */
        .particles-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
        }
        
        .particle {
            position: absolute;
            width: 3px;
            height: 3px;
            background-color: rgba(0, 255, 157, 0.9);
            border-radius: 50%;
            animation: particle-animation 3s infinite;
            box-shadow: 0 0 6px rgba(0, 255, 157, 0.8);
            filter: blur(0.5px);
        }
        
        .particle:nth-child(even) {
            background-color: rgba(255, 255, 255, 0.9);
            box-shadow: 0 0 6px rgba(255, 255, 255, 0.8);
        }
        
        @keyframes particle-animation {
            0% {
                transform: translate(0, 0) scale(0);
                opacity: 0;
            }
            20% {
                opacity: 1;
            }
            100% {
                transform: translate(var(--x), var(--y)) scale(1.2);
                opacity: 0;
            }
        }
        
        #help-button, #sound-toggle {
            position: absolute;
            bottom: 20px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 10;
            transition: all 0.3s ease;
        }
        
        #help-button {
            left: 20px;
        }
        
        #sound-toggle {
            right: 20px;
        }

        
        #game-title-container {
            text-align: center;
            margin-bottom: 50px;
            margin-top: -40px;
            z-index: 6;
            position: relative;
        }
        
        #game-button-container {
            text-align: center;
            margin-top: 50px;
            z-index: 6;
        }
        
        .button-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        #game-title {
            font-size: 4.5rem;
            font-weight: bold;
            color: #FFFFFF;
            letter-spacing: 2px;
            text-shadow: 
                0 2px 0 rgba(0, 0, 0, 0.5),
                0 4px 0 rgba(0, 255, 157, 0.3),
                0 6px 10px rgba(0, 0, 0, 0.3);
            transform: perspective(500px) rotateX(10deg);
            margin-bottom: 10px;
        }
        
        #score-display {
            font-size: 4rem;
            margin-bottom: 10px;
            color: #00FF9D;
            font-weight: bold;
        }
        
        #best-score {
            font-size: 1.8rem;
            margin-bottom: 10px;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .game-button {
            padding: 10px 24px;
            font-size: 1rem;
            background: linear-gradient(135deg, #00FF9D 0%, #00B38B 70%, #009E7F 100%);
            color: #121212;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Orbitron', sans-serif;
            margin: 10px 0;
            min-width: 150px;
            text-align: center;
            font-weight: bold;
            letter-spacing: 1px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            text-transform: uppercase;
        }
        
        .game-button:hover {
            background: linear-gradient(135deg, #00FFB3 0%, #00C49C 70%, #00AF8F 100%);
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.4);
        }
        
        .game-button:active {
            transform: translateY(1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .game-button.secondary {
            background: transparent;
            color: white;
            border: 2px solid white;
            box-shadow: none;
        }
        
        .game-button.secondary:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateY(-2px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }
        
        .user-profile {
            position: absolute;
            top: 20px;
            right: 20px;
            left: auto;
            display: flex;
            align-items: center;
            z-index: 10;
            flex-direction: row-reverse;
        }
        
        .avatar-container {
            position: relative;
            width: 32px;
            height: 32px;
            margin-left: 6px;
            margin-right: 0;
        }
        
        .avatar-border {
            position: absolute;
            top: -1.5px;
            left: -1.5px;
            right: -1.5px;
            bottom: -1.5px;
            border: 2px solid #00FF9D;
            border-radius: 50%;
            box-sizing: border-box;
        }
        
        .avatar-img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 50%;
        }
        
        .user-info {
            color: white;
            text-align: right;
        }
        
        .username {
            font-size: 11px;
            font-weight: bold;
            margin: 0;
            margin-bottom: 2px;
        }
        
        .user-id {
            font-size: 9px;
            color: #aaa;
            margin: 0;
        }
        
        #settings-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            display: none;
            z-index: 100;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }
        
        .android-scroll-container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            overscroll-behavior: contain;
        }
        
        .settings-content {
            padding: 20px;
            box-sizing: border-box;
            color: white;
            padding-bottom: 100px;
        }
        
        .settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
        }
        
        .settings-title {
            font-size: 24px;
            font-weight: bold;
            color: white;
        }
        
        .close-button {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
        }
        
        .close-button:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }
        
        .close-icon {
            color: white;
            font-size: 20px;
        }
        
        .profile-card {
            background-color: rgba(30, 30, 30, 0.8);
            border-radius: 12px;
            padding: 15px;
            display: flex;
            align-items: center;
            margin-bottom: 30px;
        }
        
        .profile-avatar {
            width: 70px;
            height: 70px;
            border-radius: 12px;
            margin-right: 15px;
            position: relative;
            overflow: hidden;
        }
        
        .profile-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .profile-avatar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 2px solid #00FF9D;
            border-radius: 12px;
            box-sizing: border-box;
        }
        
        .profile-info {
            flex: 1;
        }
        
        .username-container {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        
        .username-input {
            background-color: transparent;
            border: none;
            color: white;
            font-size: 18px;
            font-weight: bold;
            font-family: 'Orbitron', sans-serif;
            padding: 5px 0;
            width: calc(100% - 30px);
            outline: none;
        }
        
        .edit-icon {
            width: 20px;
            height: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-left: 10px;
        }
        
        .user-id-display {
            font-size: 14px;
            color: #aaa;
        }
        
        .paypal-section {
            margin-bottom: 30px;
        }
        
        .section-title {
            font-size: 16px;
            color: white;
            margin-bottom: 15px;
        }
        
        .paypal-input {
            width: 100%;
            background-color: rgba(30, 30, 30, 0.8);
            border: none;
            border-radius: 8px;
            color: white;
            font-family: 'Orbitron', sans-serif;
            padding: 12px 15px;
            box-sizing: border-box;
            margin-bottom: 15px;
            outline: none;
        }
        
        .input-container {
            position: relative;
            margin-bottom: 15px;
        }
        
        .input-edit-icon {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            color: white;
        }
        
        .description-text {
            font-size: 12px;
            color: #aaa;
            line-height: 1.5;
        }
        
        .avatars-section {
            margin-bottom: 30px;
            position: relative;
            z-index: 2;
            padding-bottom: 30px;
        }
        
        .avatars-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-top: 15px;
            padding: 0 10px;
        }
        
        .avatar-item {
            position: relative;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            overflow: hidden;
            border: 2px solid #333;
            cursor: pointer;
            transition: all 0.2s ease;
            margin: 0 auto;
        }
        
        .avatar-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .avatar-item.selected {
            border: 2px solid #4CAF50;
            box-shadow: 0 0 8px rgba(76, 175, 80, 0.8);
        }
        
        .avatar-check {
            position: absolute;
            bottom: 0;
            right: 0;
            background-color: #4CAF50;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 12px;
            opacity: 0;
        }
        
        .avatar-item.selected .avatar-check {
            opacity: 1;
        }
        
        .preload-images {
            position: absolute;
            width: 0;
            height: 0;
            overflow: hidden;
            z-index: -1;
        }
        
        .sound-toggle {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 100;
            transition: all 0.2s ease;
        }
        
        
        .sound-toggle svg {
            width: 24px;
            height: 24px;
        }
        
        .sound-toggle.muted .sound-on {
            display: none;
        }
        
        .sound-toggle:not(.muted) .sound-off {
            display: none;
        }
        
        .avatars-wrapper {
            position: relative;
            padding-bottom: 60px;
        }
        
        .ios-spacer {
            height: 60px;
            width: 100%;
        }
        
        .android-device {
            -webkit-tap-highlight-color: transparent;
        }
        
        .season-info-container {
    position: absolute;
    top: 20px;
    left: 20px;
    width: 300px;
    z-index: 10;
    border-radius: 16px;
    background: transparent;
    padding: 0;
    box-sizing: border-box;
    display: flex;
    align-items: center;
    cursor: pointer;
    box-shadow: none;
    transition: none;
    animation: none;
}

.season-info-container:active {
    box-shadow: none;
}

.season-circle-container {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 32px;
    height: 32px;
    margin: 0 0px 0 0;
}

.season-gradient-border {
    background: conic-gradient(
        #00ff9d 0deg, #00e0ff 120deg, #00ff9d 240deg, #00ff9d 360deg
    );
    border-radius: 50%;
    padding: 2px;
    width: 35px;
    height: 35px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.season-circle-text {
    background: #000;
    border-radius: 50%;
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 700;
    font-size: 11px;
    color: #00c97b;
    letter-spacing: 0.5px;
    box-shadow: none;
}

.season-info-content {
    display: flex;
    flex-direction: column;
    justify-content: center;
    margin-left: 6px;
}

.season-label {
    color: #fff;
    font-size: 12px;
    font-weight: 600;
    margin-bottom: 0px;
    letter-spacing: 0.2px;
}

.season-prize {
    color: #fff !important;
    font-size: 12px;
    font-weight: 400;
    margin-top: 1px;
    letter-spacing: 0.1px;
    text-shadow: 0 1px 4px #00ff9d44;
}


        @keyframes glowPulse {
            0%, 100% {
                box-shadow:
                    0 0 12px 2px #00FF9D66,
                    0 0 24px 4px #00FF9D33;
            }
            50% {
                box-shadow:
                    0 0 16px 3px #00FF9D99,
                    0 0 28px 6px #00FF9D44;
            }
        }
        
        .season-info-row {
    display: flex;
    flex-direction: row;
    align-items: center;
}
        
        
        
        .season-label {
            color: #FFFFFF;
            font-size: 9px;
            font-weight: 300;
            margin-bottom: 2px;
            text-align: left;
            line-height: 1.2;
        }
        
        .season-prize {
            color: #00FF9D;
            font-size: 11px;
            font-weight: 600;
            text-align: left;
            line-height: 1.2;
        }
        
        @keyframes borderGlow {
            0%, 100% { background-position: 0% 0% }
            50% { background-position: 100% 100% }
        }
    
        #scoretotal-diamond {
        width: 28px;
        height: 28px;
        background: linear-gradient(135deg, #00ff9d 0%, #00c97b 100%);
        border-radius: 8px;
        transform: rotate(45deg);
        box-shadow: 0 0 12px 2px #00FF9D44;
        margin-bottom: 7px;
        animation: diamondPulse 2s infinite ease-in-out;
    }
    @keyframes diamondPulse {
        0%, 100% { box-shadow: 0 0 12px 2px #00FF9D44, 0 0 24px 4px #00FF9D33; }
        50% { box-shadow: 0 0 24px 6px #00FF9D99, 0 0 32px 10px #00FF9D44; }
    }
    #scoretotal-value {
        font-family: 'Orbitron', sans-serif;
        font-size: 1.15rem;
        color: #fff;
        font-weight: 700;
        letter-spacing: 1px;
        text-align: center;
        margin-top: 0;
        margin-bottom: 0;
        text-shadow: 0 1px 4px #00ff9d44;
        user-select: none;
        pointer-events: none;
    }
</style>
</head>
<body>
    <div class="preload-images" id="preload-container"></div>
    <div class="container">
        <!-- User profile -->
        <div class="user-profile" id="profile-button">
            <div class="avatar-container">
                <div class="avatar-border"></div>
                <img id="avatarImg" class="avatar-img" src="avatars/avatar_default.jpg" alt="Avatar">
            </div>
            <div class="user-info">
                <p id="username" class="username">Username</p>
                <p id="userId" class="user-id">0000000000</p>
            </div>
        </div>
        
        <canvas id="game-canvas"></canvas>
        
        <div id="home-screen">
            <!-- Season information section -->
            <div id="season-info-container" class="season-info-container" style="display:none;">
                <div class="season-info-row">
                    <div class="season-circle-container">
                        <div class="season-gradient-border">
                            <div class="season-circle-text">S-</div>
                        </div>
                    </div>
                    <div class="season-info-content">
                        <div class="season-prize" style="color:white;margin-bottom:2px;">- Prize </div>
                        <div class="season-label" style="font-size:9px;color:#aaa;margin:0;">This Season</div>
                    </div>
                </div>
            </div>

            <div id="game-title-container">
                <div id="game-title">TiDash</div>
            </div>
            <div id="game-button-container">
                <button id="play-button" class="game-button">Tap to Start</button>
            </div>
            
            <!-- Scoretotal area -->
            <div id="scoretotal-area" style="position:absolute; top:16px; left:16px; bottom:auto; right:auto; display:flex; flex-direction:row; align-items:center; z-index:20;">
                <svg width="24" height="24" viewBox="0 0 24 24" style="vertical-align:middle;" xmlns="http://www.w3.org/2000/svg">
  <circle cx="12" cy="12" r="11" fill="#FFD700" stroke="#E6B800" stroke-width="2"/>
  <text x="12" y="16" text-anchor="middle" font-size="11" font-family="Arial" fill="#fff" font-weight="bold">$</text>
</svg>
<div id="scoretotal-value" style="margin-left:8px;">-</div>
            </div>
            <!-- Help button -->
            <div id="help-button">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 22C17.5228 22 22 17.5228 22 12C22 6.47715 17.5228 2 12 2C6.47715 2 2 6.47715 2 12C2 17.5228 6.47715 22 12 22Z" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M9 9C9 7.89543 9.89543 7 11 7H12C13.1046 7 14 7.89543 14 9C14 10.1046 13.1046 11 12 11V13" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M12 17.01L12.01 16.999" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
            </div>
            
            <!-- Sound toggle button -->
            <div id="sound-toggle" class="sound-toggle muted">
                <svg class="sound-on" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M14.5 8.5C14.5 8.5 16 9.57 16 12C16 14.43 14.5 15.5 14.5 15.5" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M18 5C18 5 21 7 21 12C21 17 18 19 18 19" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M3 10.5V13.5C3 14.6046 3.5 15.5 5 15.5C6.5 15.5 7 14.6046 7 13.5V10.5C7 9.39543 6.5 8.5 5 8.5C3.5 8.5 3 9.39543 3 10.5Z" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M7 10L11 7V17L7 14" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
                <svg class="sound-off" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M2 9L22 21" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M11 7L7 10H5C3.5 10 3 10.8954 3 12V12C3 13.1046 3.5 14 5 14H7L11 17V7Z" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M14.5 10.5C14.5 10.5 15.0049 10.7705 15.5 11.5" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M18 8C18 8 19.5 9.5 19.5 12" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
            </div>
        </div>
        <div id="game-over">
            <div id="promo-banner-area" style="position:absolute;width:100%;margin-top:0;padding-top:0;margin-bottom:10px;display:none;flex-direction:column;align-items:center;z-index:1000;">
                <span id="promo-sponsored-label" style="font-size:11px;color:#aaa;margin-bottom:2px;letter-spacing:1px;opacity:0.7;">Sponsored</span>
                <img id="promo-banner-img" src="" alt="Promotion" style="width:100%;max-width:480px;height:150px;object-fit:cover;border-radius:8px;cursor:pointer;display:block;border:1px solid #00FF9D;margin-left:10px;margin-right:10px;" />
            </div>
            <div class="gameover-center-content" style="display:flex;flex-direction:column;justify-content:center;align-items:center;width:100%;height:100%;padding-top:175px;padding-bottom:120px;">
                <div id="score-display">0</div>
                <div id="best-score">Best: -</div>
                <div id="season-score">Season Best: -</div>
                <div class="button-container" style="display:flex; flex-direction:row; gap:12px; justify-content:center; align-items:center;">
    <button id="home-button" class="game-button secondary">HOME</button>
    <button id="play-again" class="game-button">PLAY</button>
</div>
<button id="revive-button" class="game-button gold" style="margin-top:5px; background:linear-gradient(135deg, #FFD700 0%, #FFA500 70%, #FF8C00 100%); display:flex; align-items:center; justify-content:center; width:calc(100% - 24px); max-width:312px;">
    <svg style="width:18px; height:18px; margin-right:8px;" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M8 5.14V19.14L19 12.14L8 5.14Z" fill="currentColor" stroke="#121212" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
    </svg>
    REVIVE
</button>
<div id="revive-x2-tipoints" style="display:none;margin-top:-3px;font-size:14px;color:#FFD700;font-weight:400;opacity:0.85;text-align:center;letter-spacing:0.02em;">
    <span style="font-weight:700;">x2</span> $TID Tokens
</div>
            </div>
            <!-- Sticky user group from leaderboard (season rank & best score) -->
            <div class="leaderboard-user-row" id="gameover-user-row"></div>
        </div>
        
        <!-- Settings screen -->
        <div id="settings-screen">
            <div class="android-scroll-container">
                <div class="settings-content">
                    <div class="settings-header">
                        <div class="settings-title">Settings</div>
                        <div class="close-button" id="close-settings">
                            <span class="close-icon">✕</span>
                        </div>
                    </div>
                    
                    <div class="profile-card">
                        <div class="profile-avatar">
                            <img id="settings-avatar" src="avatars/avatar_default.jpg" alt="Avatar">
                        </div>
                        <div class="profile-info">
                            <div class="username-container">
                                <input type="text" id="username-input" class="username-input" value="Username">
                                <div class="edit-icon">
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                        <path d="M16.4745 5.40768L18.5917 7.52483M17.8358 3.54254L11.6002 9.77806C11.3979 9.98031 11.2619 10.2384 11.2104 10.5192L10.5798 13.4209L13.4816 12.7903C13.7624 12.7388 14.0205 12.6028 14.2227 12.4006L20.4582 6.16508C20.5844 6.03889 20.6846 5.88909 20.7536 5.72343C20.8226 5.55777 20.8589 5.37966 20.8605 5.19938C20.8621 5.01909 20.8289 4.84039 20.7628 4.6736C20.6967 4.50681 20.5991 4.35537 20.4749 4.22718C20.3507 4.09899 20.2022 3.99691 20.0374 3.92553C19.8726 3.85415 19.6951 3.81549 19.5157 3.81169C19.3364 3.8079 19.1574 3.83906 18.9899 3.90281C18.8224 3.96656 18.6698 4.06188 18.5401 4.18348L12.3046 10.419C12.1023 10.6212 11.9664 10.8793 11.9149 11.1601L11.2843 14.0619L14.186 13.4313C14.4668 13.3798 14.7249 13.2438 14.9272 13.0416L21.1627 6.80608C21.8106 6.15818 22.1655 5.28206 22.1529 4.36728C22.1403 3.45249 21.7612 2.58647 21.0961 1.9549C20.431 1.32333 19.5401 0.96993 18.6146 1.00182C17.689 1.03372 16.8179 1.44959 16.1974 2.12483L9.96196 8.36035C9.35302 8.96929 8.94371 9.74882 8.79747 10.5981L7.7655 15.2322C7.73328 15.3697 7.73471 15.5131 7.76969 15.6498C7.80467 15.7864 7.87221 15.9122 7.96643 16.0172C8.06066 16.1222 8.17871 16.2034 8.31082 16.2544C8.44293 16.3054 8.58559 16.3247 8.72856 16.3108L13.3627 15.2788C14.212 15.1326 14.9915 14.7233 15.6004 14.1143L21.8359 7.87877L16.4745 5.40768Z" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                                </svg>
                            </div>
                        </div>
                        <div class="user-id-display">ID : <span id="settings-user-id">0000000000</span></div>
                    </div>
                </div>
                
                <div class="paypal-section" style="display:none;">
                    <div class="section-title">Enter your USDT (TRC20) destination address</div>
                    <div class="input-container">
    <input type="email" id="paypal-email" class="paypal-input" placeholder="TAbCdEfG...wXyZ1234">
    <div class="input-edit-icon">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M16.4745 5.40768L18.5917 7.52483M17.8358 3.54254L11.6002 9.77806C11.3979 9.98031 11.2619 10.2384 11.2104 10.5192L10.5798 13.4209L13.4816 12.7903C13.7624 12.7388 14.0205 12.6028 14.2227 12.4006L20.4582 6.16508C20.5844 6.03889 20.6846 5.88909 20.7536 5.72343C20.8226 5.55777 20.8589 5.37966 20.8605 5.19938C20.8621 5.01909 20.8289 4.84039 20.7628 4.6736C20.6967 4.50681 20.5991 4.35537 20.4749 4.22718C20.3507 4.09899 20.2022 3.99691 20.0374 3.92553C19.8726 3.85415 19.6951 3.81549 19.5157 3.81169C19.3364 3.8079 19.1574 3.83906 18.9899 3.90281C18.8224 3.96656 18.6698 4.06188 18.5401 4.18348L12.3046 10.419C12.1023 10.6212 11.9664 10.8793 11.9149 11.1601L11.2843 14.0619L14.186 13.4313C14.4668 13.3798 14.7249 13.2438 14.9272 13.0416L21.1627 6.80608C21.8106 6.15818 22.1655 5.28206 22.1529 4.36728C22.1403 3.45249 21.7612 2.58647 21.0961 1.9549C20.431 1.32333 19.5401 0.96993 18.6146 1.00182C17.689 1.03372 16.8179 1.44959 16.1974 2.12483L9.96196 8.36035C9.35302 8.96929 8.94371 9.74882 8.79747 10.5981L7.7655 15.2322C7.73328 15.3697 7.73471 15.5131 7.76969 15.6498C7.80467 15.7864 7.87221 15.9122 7.96643 16.0172C8.06066 16.1222 8.17871 16.2034 8.31082 16.2544C8.44293 16.3054 8.58559 16.3247 8.72856 16.3108L13.3627 15.2788C14.212 15.1326 14.9915 14.7233 15.6004 14.1143L21.8359 7.87877L16.4745 5.40768Z" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
    </div>
</div>
<a href="https://bingx.com/en/accounts/register/" target="_blank" style="display:block;margin-top:8px;color:#00c853;font-weight:600;text-decoration:underline;text-align:left;font-size:0.75rem;max-width:100%;width:auto;overflow-wrap:break-word;white-space:normal;">
    Don't have a Crypto wallet? Create one here
</a>
<div style="height:32px;"></div>
<div class="description-text">
    The winnings from a season will be sent to your USDT (TRC20) destination address. Please make sure your address is correct.
</div>
                </div>
                
                <div class="avatars-section">
                    <div class="avatars-wrapper">
                        <div class="section-title">Select your avatar</div>
                        <div class="avatars-grid" id="avatars-grid">
                            <!-- Avatars will be added dynamically here -->
                        </div>
                        <div class="ios-spacer"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const tg = window.Telegram.WebApp;
        const gameOverScreen = document.getElementById('game-over');
        const homeScreen = document.getElementById('home-screen');
        const scoreDisplay = document.getElementById('score-display');
        const bestScoreDisplay = document.getElementById('best-score');
        const seasonScoreDisplay = document.getElementById('season-score');
        const playAgainBtn = document.getElementById('play-again');
        const homeBtn = document.getElementById('home-button');
        const playBtn = document.getElementById('play-button');
        const reviveBtn = document.getElementById('revive-button');

        // Variable to track if the player has already used the Revive button
        let hasUsedRevive = false;

        // Double-tap prevention
        document.addEventListener('touchend', function(event) {
            const now = Date.now();
            const DOUBLE_TAP_THRESHOLD = 150;
            if (now - lastTouchEnd <= DOUBLE_TAP_THRESHOLD) {
                event.preventDefault();
            }
            lastTouchEnd = now;
        }, false);
        
        let lastTouchEnd = 0;

        // Game variables
        let gameRunning = false;
        let gameMode = 'home'; // 'home', 'game', 'gameOver'
        let score = 0;
        let bestScore = 0; // Will be initialized correctly in initUserProfile
        let seasonScore = 0; // Added variable to track the season score
        
        // Variables for stars
        let stars = [];
        const maxStars = 45; // Number of stars
        
        // Variables for user profile
        let username = "";
        let userId = "";
        let avatarSrc = "/avatars/avatar_default.jpg";
        let paypalEmail = "";
        
        // Variables for background music
        let homeMusics = [
            "home_musics/dont-talk-315229.mp3",
            "home_musics/Onchain.mp3",
            "home_musics/gardens-stylish-chill-303261.mp3",
            "home_musics/gorila-315977 (1).mp3",
            "home_musics/ClicClic.mp3",
            "home_musics/night-detective-226857.mp3",
            "home_musics/movement.mp3",
            "home_musics/drive-breakbeat.mp3",
            "home_musics/glossy.mp3",
            "home_musics/the-best-jazz-club.mp3",
            "home_musics/lofi-chill.mp3",
            "home_musics/unlock-me.mp3",
            "home_musics/relaxed-vlog-night.mp3",
            "home_musics/password-infinity.mp3",
            "home_musics/weeknds.mp3",
            "home_musics/guitar-electro-sport-trailer.mp3"
        ];
        let currentMusicIndex = -1;
        let backgroundMusicElement = document.getElementById('backgroundMusic');
        
        // Variable to track if the music is pending autoplay
        window.musicPendingAutoplay = true;
        
        // Variables to manage separately background music and game sounds
        let isMusicEnabled = false; // Controls only background music
        let isGameSoundEnabled = true; // Controls only game sounds (always enabled by default)
        let userPrefersMusicEnabled = false; // Changed from localStorage to variable
        
        // Variable to track if the music has already been activated by the user
        let musicActivatedByUser = false;
        
        // Optimized audio system for mobile with Web Audio API
        let audioContext;
        const audioBuffers = {};
        const audioSources = {};
        let audioInitialized = false;
        
        // Initialize audio system
        function initAudioSystem() {
            try {
                // Create audio context
                window.AudioContext = window.AudioContext || window.webkitAudioContext;
                audioContext = new AudioContext();
                
                // Preload sounds
                preloadSounds();
                
                // Mark as initialized
                audioInitialized = true;
                
                console.log("Audio system initialized");
            } catch (error) {
                console.error("Audio initialization error:", error);
                // Fallback to the standard method if Web Audio API is not supported
                audioInitialized = false;
            }
        }
        
        // Preload sounds for instant playback
        function preloadSounds() {
            const sounds = {
                'userTap': document.getElementById('userTapSound'),
                'success': document.getElementById('successSound'),
                'gameOver': document.getElementById('gameOverSound'),
                'showScore': document.getElementById('showScoreSound'),
                'borderTouch': document.getElementById('borderTouchSound')
            };
            
            // For each sound
            for (const [name, audioElement] of Object.entries(sounds)) {
                if (!audioElement) continue;
                
                // Store the audio element for fallback
                audioSources[name] = audioElement;
                
                // Preload with Web Audio API
                if (audioContext) {
                    fetch(audioElement.src)
                        .then(response => response.arrayBuffer())
                        .then(arrayBuffer => audioContext.decodeAudioData(arrayBuffer))
                        .then(audioBuffer => {
                            audioBuffers[name] = audioBuffer;
                            console.log(`Sound ${name} preloaded`);
                        })
                        .catch(error => {
                            console.error(`Error preloading sound ${name}:`, error);
                        });
                }
            }
        }
        
        // Play sound with minimal latency
        function playSound(name) {
            // Only play sounds if we're in game mode and the sound is enabled
            if (gameMode !== 'game' && name === 'borderTouch') {
                return;
            }
            
            // Disable sounds if background music is enabled
            if (!isGameSoundEnabled || isMusicEnabled) {
                return;
            }
            
            // If the audio system is not initialized, initialize it
            if (!audioInitialized && typeof AudioContext !== 'undefined') {
                initAudioSystem();
            }
            
            try {
                // If Web Audio API is available and the sound is preloaded
                if (audioInitialized && audioContext && audioBuffers[name]) {
                    // Check if the context is suspended (mobile restriction)
                    if (audioContext.state === 'suspended') {
                        audioContext.resume();
                    }
                    
                    // Create a sound source
                    const source = audioContext.createBufferSource();
                    source.buffer = audioBuffers[name];
                    
                    // Connect to the audio output
                    source.connect(audioContext.destination);
                    
                    // Play immediately
                    source.start(0);
                    return;
                }
                
                // Fallback to the standard method
                if (audioSources[name]) {
                    const audio = audioSources[name];
                    audio.currentTime = 0;
                    
                    // Use a promise to handle playback
                    const playPromise = audio.play();
                    if (playPromise !== undefined) {
                        playPromise.catch(error => {
                            console.error(`Audio playback error (${name}):`, error);
                            
                            // If the error is related to user interaction, initialize the audio system
                            if (error.name === 'NotAllowedError') {
                                // We can't do anything here, we need user interaction
                                console.log("User interaction required for audio playback");
                            }
                        });
                    }
                }
            } catch (error) {
                console.error(`Error playing sound ${name}:`, error);
            }
        }
        
        // Activate audio on user interaction
        function setupAudioActivation() {
            const activateAudio = () => {
                // Initialize the audio system
                if (!audioInitialized) {
                    initAudioSystem();
                }
                
                // Play a silent sound to unlock audio on mobile
                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume().then(() => {
                        console.log("Audio context resumed");
                        
                        // Create a silent oscillator to "wake up" the audio
                        const oscillator = audioContext.createOscillator();
                        const gainNode = audioContext.createGain();
                        gainNode.gain.value = 0;
                        oscillator.connect(gainNode);
                        gainNode.connect(audioContext.destination);
                        oscillator.start(0);
                        oscillator.stop(audioContext.currentTime + 0.001)
                    });
                }
                
                // Remove event listeners
                document.removeEventListener('click', activateAudio, true);
                document.removeEventListener('touchstart', activateAudio, true);
                document.removeEventListener('keydown', activateAudio, true);
            };
            
            // Add event listeners
            document.addEventListener('click', activateAudio, true);
            document.addEventListener('touchstart', activateAudio, true);
            document.addEventListener('keydown', activateAudio, true);
        }
        
        let ball = {
            x: 0,
            y: 0,
            radius: 0,
            speed: 0,
            direction: 1 // 1 for right, -1 for left
        };
        let line = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
        };
        let squares = [];
        let fadingSquares = []; // Squares that are fading out
        let particles = []; // Particles for ball explosion
        let gameOverAnimation = false;
        let gameOverAnimationComplete = false;
        let lastSquareTime = 0;
        let squareInterval = 1100; // Increased interval to reduce difficulty
        let lastFrameTime = 0;
        let greenSquareChance = 0.2; // 20% chance for green squares
        let lineProximityThreshold = 0; // Minimal distance between squares and the line
        let canSpawnNewSquare = true; // Variable to control square appearance

        // Return to home screen
        function goToHome() {
            // Clean up the game state
            squares = [];
            fadingSquares = [];
            particles = [];
            
            // Change the game mode
            gameMode = 'home';
            
            // Hide the game over screen and show the home screen
            gameOverScreen.style.display = 'none';
            homeScreen.style.display = 'flex';
            
            // Reset animation variables
            gameOverAnimation = false;
            gameOverAnimationComplete = false;
            
            // Reset ball and line positions for the home screen
            ball.x = canvas.width / 2;
            ball.y = canvas.height * 0.5;
            ball.direction = Math.random() > 0.5 ? 1 : -1;
            ball.speed = canvas.width * 0.0008;
            
            // Reset line position for the home screen
            line.x = (canvas.width - line.width) / 2;
            line.y = ball.y - ball.radius;
            
            // Clear the canvas completely to avoid visual artifacts
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Show the user profile on the home screen
            document.getElementById("profile-button").style.display = 'flex';
            
            // Ensure the game loop is running for the home screen animation
            if (!gameRunning) {
                gameRunning = true;
                lastFrameTime = null;
                if (window.gameLoopAnimationId) {
                    cancelAnimationFrame(window.gameLoopAnimationId);
                }
                window.gameLoopAnimationId = requestAnimationFrame(gameLoop);
            }
            
            // Manage background music (start on home screen)
            manageBackgroundMusic();
            
            console.log("Return to home screen");
        }

        // Initialize the game
        function initGame() {
            console.log("Game initialization...");
            
            // Set canvas size to match container
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            // Set initial game mode to home screen
            gameMode = 'home';
            
            // Initialize ball - larger radius
            ball.radius = canvas.width * 0.035;
            ball.y = canvas.height * 0.5; // Middle of the screen vertically
            ball.x = canvas.width / 2;
            ball.speed = canvas.width * 0.0008; // Slightly faster speed
            ball.direction = Math.random() > 0.5 ? 1 : -1; // Direction aléatoire comme dans goToHome()
            
            // Initialize line - 80% of width and same height as ball
            line.width = canvas.width * 0.8;
            line.height = ball.radius * 2; // Same height as the ball diameter
            line.x = (canvas.width - line.width) / 2;
            line.y = ball.y - ball.radius; // Center the ball on the line
            
            // Initialize the stars
            initStars();
            
            // Configure audio activation
            setupAudioActivation();
            
            // CRITICAL: First retrieve the best season score from the server
            // before initializing the user profile
            fetchUserSeasonScore();
            
            // Initialize the user profile
            initUserProfile();
            
            // Send user data to the server for the admin panel
            sendUserDataToServer();
            
            // Reset game state
            squares = [];
            fadingSquares = [];
            particles = [];
            gameOverAnimation = false;
            gameOverAnimationComplete = false;
            score = 0;
            
            // Reset the frame time to avoid jumps
            lastFrameTime = null;
            
            // Ensure the game loop is running for the home screen animation
            // Use the same approach as in goToHome()
            gameRunning = true;
            
            // Cancel the previous animation frame if it exists
            if (window.gameLoopAnimationId) {
                cancelAnimationFrame(window.gameLoopAnimationId);
            }
            
            // Start a new game loop
            window.gameLoopAnimationId = requestAnimationFrame(gameLoop);
            
            console.log("Game initialized with the ball in motion on the home screen");
        }
        
        // Initialize stars
        function initStars() {
            stars = [];
            for (let i = 0; i < maxStars; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    radius: Math.random() * 1.2 + 0.3, // Size between 0.3 and 1.5 pixels
                    opacity: Math.random() * 0.4 + 0.3, // Opacity between 0.3 and 0.7 (increased for better visibility)
                    speed: Math.random() * 0.2 + 0.05, // Speed between 0.05 and 0.25 pixels per frame
                    direction: Math.random() * Math.PI * 2 // Random direction in radians
                });
            }
        }
        
        // Draw stars
        function drawStars() {
            // Draw stars only on the home screen and during the game
            if (gameMode === 'home' || gameMode === 'game') {
                for (let i = 0; i < stars.length; i++) {
                    const star = stars[i];
                    
                    // Update position
                    star.x += Math.cos(star.direction) * star.speed;
                    star.y += Math.sin(star.direction) * star.speed;
                    
                    // If the star goes off the screen, replace it on the other side
                    if (star.x < 0) star.x = canvas.width;
                    if (star.x > canvas.width) star.x = 0;
                    if (star.y < 0) star.y = canvas.height;
                    if (star.y > canvas.height) star.y = 0;
                    
                    // Draw the star
                    ctx.beginPath();
                    ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 255, 255, ${star.opacity})`;
                    ctx.fill();
                }
            }
        }

        // Start the actual gameplay
        function startGame() {
            console.log("Starting new game from home screen");
            
            // Hide home screen
            homeScreen.style.display = 'none';
            
            // Hide the user profile during the game
            document.getElementById("profile-button").style.display = 'none';
            
            // Clear the canvas completely to avoid visual artifacts
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Reset game state - Use the resetGame() function without reinitializing
            resetGame();
            
            // Play sound effect
            playSound('userTap');
        }

        // Game loop
        function gameLoop(timestamp) {
            // Handle deltaTime with a maximum limit to avoid erratic behaviors after pause
            if (!lastFrameTime) lastFrameTime = timestamp;
            let deltaTime = timestamp - lastFrameTime;
            
            // Limit deltaTime to 100ms max to avoid too large jumps after pause/inactivity
            if (deltaTime > 100) deltaTime = 100;
            
            lastFrameTime = timestamp;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw stars in the background
            drawStars();
            
            // Update ball position for all modes (including the home screen)
            // The ball should move on the home screen but without making a sound
            if (gameMode !== 'gameOver' || !gameOverAnimation) {
                ball.x += ball.speed * ball.direction * deltaTime;
                
                // Check if ball hits the edge of the line
                if (ball.x - ball.radius < line.x) {
                    ball.x = line.x + ball.radius;
                    ball.direction = 1;
                    
                    // Only play border touch sound during gameplay, not on home screen
                    if (gameMode === 'game') {
                        playSound('borderTouch');
                    }
                } else if (ball.x + ball.radius > line.x + line.width) {
                    ball.x = line.x + line.width - ball.radius;
                    ball.direction = -1;
                    
                    // Only play border touch sound during gameplay, not on home screen
                    if (gameMode === 'game') {
                        playSound('borderTouch');
                    }
                }
            }
            
            // Always draw the line
            drawLine();
            
            // Draw the ball only if we're not in a game over animation
            if (gameMode !== 'gameOver' || !gameOverAnimation) {
                drawBall();
            }
            
            // Handle game elements (particles, squares, etc.)
            if (gameMode === 'game' || gameMode === 'gameOver') {
                // Update and draw particles - Déplacer avant les carrés pour que les particules soient visibles
                updateParticles(deltaTime);
                
                // Update and draw squares
                updateSquares(deltaTime);
                
                // Update and draw fading squares
                updateFadingSquares(deltaTime);
                
                // Check if the game over animation is complete
                if (gameMode === 'gameOver' && gameOverAnimation && particles.length === 0 && fadingSquares.length === 0) {
                    gameOverAnimationComplete = true;
                    console.log("Game over animation completed");
                }
                
                if (gameMode === 'game') {
                    // Check for collisions
                    if (checkCollisions()) {
                        // Do not quit the game loop, let the game over animation continue
                        console.log("Collision detected, starting game over animation");
                    } else {
                        // Spawn new squares only if we're not in a game over
                        if ((squares.length === 0) || (squares.length > 0 && squares[squares.length-1].y > canvas.height * 0.33)) {
                            spawnSquare();
                            lastSquareTime = Date.now();
                            
                            // Gradually decrease spawn interval
                            if (squareInterval > 500) {
                                squareInterval -= 10;
                            }
                        }
                    }
                    
                    // Draw score
                    drawScore();
                }
            }
            
            // Continue the game loop with better animation frame management
            if (gameRunning) {
                // Cancel the previous animation frame if it exists
                if (window.gameLoopAnimationId) {
                    cancelAnimationFrame(window.gameLoopAnimationId);
                }
                
                // Request a new frame
                window.gameLoopAnimationId = requestAnimationFrame(gameLoop);
            } else if (window.gameLoopAnimationId) {
                // Clean up the animation frame if the game is stopped
                cancelAnimationFrame(window.gameLoopAnimationId);
                window.gameLoopAnimationId = null;
            }
        }

        // Spawn a new square
        function spawnSquare() {
            // Larger squares
            const size = canvas.width * 0.07;
            
            // Make sure squares pass through the horizontal line
            // Calculate a position that will ensure the square passes through the line
            const lineCenter = line.x + line.width / 2;
            const lineWidth = line.width;
            
            // Random position that ensures passing through the line
            const minX = Math.max(0, line.x - size);
            const maxX = Math.min(canvas.width - size, line.x + line.width);
            const x = minX + Math.random() * (maxX - minX);
            
            const isGreen = Math.random() < greenSquareChance;
            
            // Random diagonal angle for falling, but ensure it passes through the line
            const targetX = line.x + Math.random() * line.width;
            const targetY = line.y;
            
            // Calculate angle to ensure it passes through the line
            const dx = targetX - (x + size/2);
            const dy = targetY - (-size/2);
            const angle = Math.atan2(dx, dy);
            
            // Limit the angle to prevent too horizontal trajectories
            const limitedAngle = Math.max(Math.min(angle, Math.PI/4), -Math.PI/4);
            
            squares.push({
                x: x,
                y: -size,
                size: size,
                speed: canvas.height * 0.0005,
                isGreen: isGreen,
                rotation: 0,
                rotationSpeed: 0.01 * (Math.random() > 0.5 ? 1 : -1),
                angle: limitedAngle,
                velocityX: Math.sin(limitedAngle),
                velocityY: Math.cos(limitedAngle)
            });
        }

        // Update squares positions
        function updateSquares(deltaTime) {
            // Update regular squares
            for (let i = squares.length - 1; i >= 0; i--) {
                const square = squares[i];
                
                if (!gameOverAnimation) {
                    // Move square diagonally
                    square.x += square.velocityX * square.speed * deltaTime;
                    square.y += square.velocityY * square.speed * deltaTime;
                }
                
                // Update rotation
                square.rotation += square.rotationSpeed * deltaTime;
                
                // Check if square has reached the bottom area (above score)
                const scoreAreaY = canvas.height * 0.7; // Position plus haute (70% au lieu de 80%)
                
                if (square.y > scoreAreaY && !gameOverAnimation) {
                    // Add to fading squares and remove from regular squares
                    square.fadeStartTime = Date.now();
                    square.fadeTime = 1500; // 1.5 seconds for fade animation
                    square.originalSize = square.size;
                    fadingSquares.push(square);
                    squares.splice(i, 1);
                    continue;
                }
                
                // Remove squares that are off-screen horizontally
                if ((square.x < -square.size || square.x > canvas.width) && !gameOverAnimation) {
                    squares.splice(i, 1);
                    continue;
                }
                
                // Draw rotating square
                ctx.save();
                ctx.translate(square.x + square.size/2, square.y + square.size/2);
                ctx.rotate(square.rotation);
                ctx.fillStyle = square.isGreen ? '#00FF9D' : '#FFFFFF';
                ctx.fillRect(-square.size/2, -square.size/2, square.size, square.size);
                ctx.restore();
            }
        }

        // Update fading squares
        function updateFadingSquares(deltaTime) {
            for (let i = fadingSquares.length - 1; i >= 0; i--) {
                const square = fadingSquares[i];
                
                // Calculate how much time has passed since fade started
                const fadeElapsed = Date.now() - square.fadeStartTime;
                const fadeProgress = Math.min(fadeElapsed / square.fadeTime, 1);
                
                // Update rotation (continue rotating while fading)
                square.rotation += square.rotationSpeed * deltaTime;
                
                // Calculate new size based on fade progress (shrink to nothing)
                const newSize = square.originalSize * (1 - fadeProgress);
                
                // Remove if fade is complete
                if (fadeProgress >= 1) {
                    fadingSquares.splice(i, 1);
                    continue;
                }
                
                // Draw fading square
                ctx.save();
                ctx.translate(square.x + square.originalSize/2, square.y + square.originalSize/2);
                ctx.rotate(square.rotation);
                ctx.fillStyle = square.isGreen ? '#00FF9D' : '#FFFFFF';
                ctx.globalAlpha = 1 - fadeProgress;
                ctx.fillRect(-newSize/2, -newSize/2, newSize, newSize);
                ctx.globalAlpha = 1;
                ctx.restore();
            }
        }

        // Create explosion particles from the ball
        function createExplosion(x, y, color) {
            console.log(`Creating explosion at (${x}, ${y}) with color ${color}`);
            
            const particleCount = 120;
            const particleSize = ball.radius / 4;
            
            for (let i = 0; i < particleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 8 + 3;
                const distance = Math.random() * ball.radius;
                
                particles.push({
                    x: x + Math.cos(angle) * distance,
                    y: y + Math.sin(angle) * distance,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: particleSize * (Math.random() * 0.5 + 0.3),
                    color: color || '#00FF9D',
                    alpha: 1,
                    fadeSpeed: 0.01 + Math.random() * 0.02,
                    creationTime: Date.now()
                });
            }
        }

        // Update and draw particles
        function updateParticles(deltaTime) {
            // If no particle, do nothing
            if (particles.length === 0) return;
            
            // Limit the deltaTime for particles to avoid erratic behaviors
            const particleDeltaTime = Math.min(deltaTime, 100);
            
            // Trace the number of particles for debugging
            if (particles.length > 0 && particles.length % 50 === 0) {
                console.log(`Updating ${particles.length} particles`);
            }
            
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                
                // Check if the particle is too old (more than 10 seconds) to avoid memory leaks
                const particleAge = Date.now() - (particle.creationTime || Date.now());
                if (particleAge > 10000) { // 10 seconds max
                    particles.splice(i, 1);
                    continue;
                }
                
                // Update position - with a constant speed factor to avoid deltaTime variations
                particle.x += particle.vx * particleDeltaTime * 0.1;
                particle.y += particle.vy * particleDeltaTime * 0.1;
                
                // Update alpha - slow down the disappearance
                particle.alpha -= particle.fadeSpeed * particleDeltaTime * 0.03;
                
                // Remove faded particles
                if (particle.alpha <= 0) {
                    particles.splice(i, 1);
                    continue;
                }
                
                // Draw particle
                ctx.save();
                ctx.globalAlpha = particle.alpha;
                ctx.fillStyle = particle.color;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore(); // Always restore the context to reset globalAlpha
            }
        }

        // Draw the ball
        function drawBall() {
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fillStyle = '#00FF9D'; // Original green
            ctx.fill();
            ctx.closePath();
        }

        // Draw the line
        function drawLine() {
            // Draw the actual line with rounded corners
            ctx.fillStyle = '#333333';
            
            // Use rounded rectangle
            const radius = line.height / 2;
            ctx.beginPath();
            ctx.moveTo(line.x + radius, line.y);
            ctx.lineTo(line.x + line.width - radius, line.y);
            ctx.arcTo(line.x + line.width, line.y, line.x + line.width, line.y + radius, radius);
            ctx.lineTo(line.x + line.width, line.y + line.height - radius);
            ctx.arcTo(line.x + line.width, line.y + line.height, line.x + line.width - radius, line.y + line.height, radius);
            ctx.lineTo(line.x + radius, line.y + line.height);
            ctx.arcTo(line.x, line.y + line.height, line.x, line.y + line.height - radius, radius);
            ctx.lineTo(line.x, line.y + radius);
            ctx.arcTo(line.x, line.y, line.x + radius, line.y, radius);
            ctx.closePath();
            ctx.fill();
        }
        
        // Draw score at the bottom
        function drawScore() {
            ctx.fillStyle = '#FFFFFF';
            ctx.font = 'bold ' + (canvas.width * 0.13) + 'px Orbitron';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            // Affichage personnalisé du score : 0.00 par défaut, sinon score * 0.05 avec 2 décimales
            let displayScore = score === 0 ? '0.00' : (score * 0.05).toFixed(2);
            ctx.fillText(displayScore, canvas.width / 2, canvas.height * 0.85);
        }

        // Check for collisions between ball and squares
        function checkCollisions() {
            for (let i = 0; i < squares.length; i++) {
                const square = squares[i];
                
                // Calculate distance between ball and square center
                const dx = ball.x - (square.x + square.size / 2);
                const dy = ball.y - (square.y + square.size / 2);
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Check if ball collides with square
                if (distance < ball.radius + square.size / 2) {
                    // If it's a green square, collect it
                    if (square.isGreen) {
                        // Play the sound when the ball touches a green square
                        playSound('success');
                        
                        // Remove the square
                        squares.splice(i, 1);
                        
                        // Increment score
                        score++;
                        
                        // Update season score if current score is better
                        if (score > seasonScore) {
                            seasonScore = score;
                            console.log(`New season best: ${seasonScore}`);
                        }
                        
                        // Update best score if needed
                        if (score > bestScore) {
                            bestScore = score;
                            console.log(`New all-time best: ${bestScore}`);
                        }
                        
                        // Create explosion effect
                        createExplosion(square.x + square.size / 2, square.y + square.size / 2, '#00FF9D');
                        
                        // Send the updated score to the server immediately
                        sendUserDataToServer();
                        
                        return false;
                    } else {
                        // Game over if it's a white square
                        // Play the sound when the ball touches a white square
                        playSound('gameOver');
                        
                        // Set game over mode first to prevent multiple collisions
                        gameMode = 'gameOver';
                        gameOverAnimation = true;
                        gameOverAnimationComplete = false;
                        
                        console.log("Game over sequence started");
                        
                        // Create an explosion effect only for the ball
                        createExplosion(ball.x, ball.y, '#00FF9D');
                        
                        // Add all squares to the fading squares array
                        // so they fade out gradually like at the end of their fall
                        for (let i = 0; i < squares.length; i++) {
                            const square = squares[i];
                            
                            // Add the square to the fading squares array
                            fadingSquares.push({
                                x: square.x,
                                y: square.y,
                                originalSize: square.size,
                                rotation: square.rotation,
                                rotationSpeed: square.rotationSpeed,
                                isGreen: square.isGreen,
                                fadeStartTime: Date.now(),
                                fadeTime: 1000
                            });
                        }
                        
                        // Empty the original squares array since they are now fading
                        squares.length = 0;
                        
                        // Show the game over screen with a longer delay to see the complete animation
                        setTimeout(() => {
                            handleGameOver();
                        }, 1000);
                        
                        return true;
                    }
                }
            }
            return false;
        }
        
        // Function to show game over screen
        function showGameOverScreen() {
    // Render promo banner (fetch from server)
    if (typeof renderGameOverPromoBanner === 'function') {
        renderGameOverPromoBanner();
    } else if (document.getElementById('promo-banner-area')) {
        // Fallback: try to call if loaded late
        setTimeout(() => {
            if (typeof renderGameOverPromoBanner === 'function') renderGameOverPromoBanner();
        }, 100);
    }
            // Play sound when the score popup is displayed (do NOT play gameOver sound here)
            playSound('showScore');
            
            // Update score displays
            document.getElementById('score-display').textContent = (score * 0.05).toFixed(2);
            document.getElementById('best-score').textContent = `Best: ${(bestScore * 0.05).toFixed(2)}`;
            
            // CRITICAL FIX: Handle season score correctly on game over
            const seasonScoreElement = document.getElementById('season-score');
            seasonScoreElement.style.display = 'block';
            
            // Update the user row with the latest information
            if (window.renderGameOverStickyUserRow) {
                window.renderGameOverStickyUserRow();
            }
            
            // Try to use the known season score first, which was updated just before
            if (score > seasonScore) {
                // If the current score is better, display it immediately
                seasonScoreElement.textContent = `Season Best: ${score} 🏆`;
                
                // Update the server in the background (without blocking the UI)
                saveBestSeasonScore(score);
            } else {
                // Use the value already retrieved just before
                seasonScoreElement.textContent = `Season Best: ${seasonScore} 🏆`;
            }
            
            // Update the game mode
            gameMode = 'gameOver';
            
            // Manage background music (stop during game over)
            manageBackgroundMusic();
            
            // Show the game over screen
            const gameOverScreen = document.getElementById('game-over');
            gameOverScreen.style.display = 'flex';
            
            // Force a reflow to make the transition work
            void gameOverScreen.offsetWidth;
            
            // Add the visible class to trigger the animation
            gameOverScreen.classList.add('visible');
            console.log("Game over screen displayed");
        }
        
        // Function to save the best season score in the background
        function saveBestSeasonScore(newScore) {
            console.log(`Saving new season best: ${newScore}`);
            
            // Update the local variable
            seasonScore = newScore;
            
            // Update the server in the background without waiting for the response
            fetch('/api/seasons/active')
              .then(response => response.ok ? response.json() : null)
              .then(seasonData => {
                  if (!seasonData) return;
                  
                  // Envoyer le nouveau score au serveur
                  return fetch(`/api/seasons/${seasonData.id}/scores`, {
                      method: 'POST',
                      headers: { 'Content-Type': 'application/json' },
                      body: JSON.stringify({ userId: userId, score: newScore })
                  });
              })
              .catch(err => console.error("Error saving season best:", err));
        }
        
        // Function to hide game over screen
        function hideGameOver() {
            // Hide the game over screen immediately without animation
            gameOverScreen.style.display = 'none';
            // Reset the visible class for future uses
            gameOverScreen.classList.remove('visible');
            
            // Reset the state of the end game animation
            gameOverAnimation = false;
            gameOverAnimationComplete = false;
        }

        // Function to reset the game and start a new game
        function resetGame() {
            console.log("Resetting game completely");
            
            // Hide game over screen
            hideGameOver();
            
            // Cancel the previous animation frame to avoid duplicates
            if (window.gameLoopAnimationId) {
                cancelAnimationFrame(window.gameLoopAnimationId);
                window.gameLoopAnimationId = null;
            }
            
            // Clear the canvas completely to avoid visual artifacts
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Reset game state - clear completely the arrays to avoid memory leaks
            squares.length = 0;
            fadingSquares.length = 0;
            particles.length = 0;
            
            // Reset the game variables
            gameOverAnimation = false;
            gameOverAnimationComplete = false;
            score = 0;
            
            // Reset the hasUsedRevive variable when starting a new game
            hasUsedRevive = false;
            
            // Update game mode
            gameMode = 'game';
            
            // Reset ball position and speed
            ball.x = canvas.width / 2;
            ball.y = canvas.height * 0.5;
            ball.direction = Math.random() > 0.5 ? 1 : -1;
            ball.speed = canvas.width * 0.0008;
            
            // Reset line position
            line.x = (canvas.width - line.width) / 2;
            line.y = ball.y - ball.radius;
            
            // Reset spawn interval
            squareInterval = 1000; // Reset to initial spawn interval
            lastSquareTime = Date.now();
            
            // Hide profile button during gameplay
            document.getElementById("profile-button").style.display = 'none';
            
            // Manage background music for game mode
            manageBackgroundMusic();
            
            // Reset the frame time to avoid jumps
            lastFrameTime = null;
            
            // Ensure the game loop is properly reset and running
            gameRunning = true;
            
            // Force a new start of the game loop
            window.gameLoopAnimationId = requestAnimationFrame(gameLoop);
            
            // Play sound effect
            playSound('userTap');
            
            console.log("Game reset and restarted");
        }

        // Handle screen tap/click
        function handleTap() {
            if (gameMode === 'game') {
                // Change ball direction
                ball.direction *= -1;
                
                // Play sound when the user touches the screen
                playSound('userTap');
            }
        }

        // Resize handler
        function resizeCanvas() {
            // Set canvas size to match container
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            // Adjust ball size based on canvas width
            ball.radius = canvas.width * 0.035;
            
            // Adjust line dimensions
            line.width = canvas.width * 0.8;
            line.height = ball.radius * 2;
            
            // Reposition ball and line
            if (gameMode === 'home') {
                // On home screen, position in the middle
                ball.x = canvas.width / 2;
                ball.y = canvas.height * 0.5;
                line.x = (canvas.width - line.width) / 2;
                line.y = ball.y - ball.radius;
            }
            
            // Redraw stars for new dimensions
            initStars();
            
            console.log(`Canvas resized to ${canvas.width}x${canvas.height}`);
        }

        // Handle window resize
        function handleResize() {
            // Delay resize to avoid performance issues during resize
            clearTimeout(window.resizeTimer);
            window.resizeTimer = setTimeout(function() {
                resizeCanvas();
            }, 250);
        }

        // Add resize event listener
        window.addEventListener('resize', handleResize);

        // Event listeners
        canvas.addEventListener('click', handleTap);
        
        // Handle play again button click
        playAgainBtn.addEventListener('click', resetGame);

        playBtn.addEventListener('click', startGame);

        // Generate a random username
        function generateRandomUsername() {
            const adjectives = [
                "Cosmic", "Stellar", "Quantum", "Neon", "Cyber", 
                "Digital", "Pixel", "Techno", "Hyper", "Mega", 
                "Ultra", "Retro", "Future", "Laser", "Plasma", 
                "Crystal", "Glitch", "Vector", "Synth", "Astro"
            ];
            
            const nouns = [
                "Runner", "Racer", "Dasher", "Pilot", "Navigator", 
                "Explorer", "Voyager", "Jumper", "Drifter", "Surfer", 
                "Rider", "Hunter", "Ninja", "Warrior", "Knight", 
                "Wizard", "Hacker", "Gamer", "Player", "Master"
            ];
            
            const randomAdjective = adjectives[Math.floor(Math.random() * adjectives.length)];
            const randomNoun = nouns[Math.floor(Math.random() * nouns.length)];
            
            return randomAdjective + randomNoun;
        }
        
        // Generate a random ID of 10 digits
        function generateRandomUserId() {
            let id = "";
            for (let i = 0; i < 10; i++) {
                id += Math.floor(Math.random() * 10);
            }
            return id;
        }
        
        // Select a random avatar
        function getRandomAvatar() {
            return "/avatars/avatar_default.jpg";
        }
        
        // Variable to avoid multiple account creations
        let isCreatingUser = false;
        
        // Initialize or retrieve the user profile
        function initUserProfile() {
            try {
                console.log("Initializing user profile...");
                
                // Check if we already have a user ID in memory
                const storedUserId = localStorage.getItem("tidashUserId");
                const storedUsername = localStorage.getItem("tidashUsername");
                
                // Check if we have a Telegram ID available via the Telegram API
                let telegramId = null;
                let telegramUsername = null;
                
                if (window.Telegram && window.Telegram.WebApp && window.Telegram.WebApp.initDataUnsafe && window.Telegram.WebApp.initDataUnsafe.user) {
                    telegramId = window.Telegram.WebApp.initDataUnsafe.user.id.toString();
                    telegramUsername = window.Telegram.WebApp.initDataUnsafe.user.username || null;
                    console.log("Found Telegram user:", telegramId, telegramUsername);
                    
                    // If we have a Telegram ID, clear the localStorage to avoid conflicts
                    if (telegramId) {
                        localStorage.removeItem("tidashUserId");
                        localStorage.removeItem("tidashUsername");
                        console.log("Cleared localStorage to avoid conflicts with Telegram account");
                    }
                }
                
                if (storedUserId && !telegramId) {
                    console.log("Found stored user ID in localStorage:", storedUserId);
                }
                
                // Get device ID from cookie (more persistent than localStorage)
                let deviceId = getCookie("tidashDeviceId");
                if (!deviceId) {
                    deviceId = generateRandomUserId();
                    setCookie("tidashDeviceId", deviceId, 365); // Cookie valide 1 an
                    console.log("Generated new device ID:", deviceId);
                } else {
                    console.log("Found existing device ID in cookie:", deviceId);
                }
                
                // If we have a Telegram ID, we use it as the primary identifier
                // instead of deviceId for user lookup
                const searchEndpoint = telegramId 
                    ? `/api/users/telegram/${telegramId}` 
                    : `/api/users/device/${deviceId}`;
                
                // Fetch user data from server using appropriate ID
                fetch(searchEndpoint)
                    .then(response => {
                        if (response.status === 404) {
                            // User not found, create a new user
                            console.log("User not found on server, creating new user...");
                            
                            // Check if a creation is already in progress
                            if (isCreatingUser) {
                                console.log("User creation already in progress, skipping duplicate creation");
                                return null;
                            }
                            
                            // Mark that a creation is in progress
                            isCreatingUser = true;
                            
                            // Always generate a new ID for new players
                            userId = generateRandomUserId();
                            console.log("Generated new ID for new player:", userId);
                            
                            // Use the stored username or generate a new one
                            username = storedUsername || generateRandomUsername();
                            
                            // Create new user data
                            const userData = {
                                gameId: userId,
                                gameUsername: username,
                                bestScore: 0,
                                seasonScore: 0,
                                musicEnabled: true,
                                deviceId: deviceId
                            };
                            
                            // Add Telegram information if available
                            if (telegramId) {
                                userData.telegramId = telegramId;
                                userData.telegramUsername = telegramUsername;
                            }
                            
                            console.log("Creating new user:", userData);
                            
                            // Send new user data to server
                            return fetch('/api/users', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify(userData)
                            })
                            .then(response => {
                                if (!response.ok) {
                                    throw new Error('Failed to create user');
                                }
                                return response.json();
                            })
                            .then(data => {
                                console.log("New user created:", data);
                                
                                // Store the ID and username locally for persistence
                                localStorage.setItem("tidashUserId", userId);
                                localStorage.setItem("tidashUsername", username);
                                
                                // Check for an active season and register the user
                                console.log("Checking for active season to add new user to ranking...");
                                fetch('/api/seasons/active')
                                    .then(response => {
                                        if (response.ok) {
                                            return response.json();
                                        } else {
                                            console.log("No active season found");
                                            return null;
                                        }
                                    })
                                    .then(seasonData => {
                                        if (seasonData && seasonData.id) {
                                            console.log(`Adding user ${userId} to season ${seasonData.id} with initial score 0`);
                                            // Add the user to the season ranking with a score of 0
                                            return fetch(`/api/seasons/${seasonData.id}/scores/${userId}`, {
                                                method: 'POST',
                                                headers: {
                                                    'Content-Type': 'application/json'
                                                },
                                                body: JSON.stringify({ score: 0 })
                                            });
                                        }
                                    })
                                    .then(response => {
                                        if (response && response.ok) {
                                            console.log("User added to season ranking successfully");
                                        }
                                    })
                                    .catch(error => {
                                        console.error("Error adding user to season ranking:", error);
                                    });
                                
                                // Update UI
                                updateUserProfileDisplay();
                                updateScoreDisplay();
                                updateSoundToggleDisplay();
                                
                                // Reset the creation flag
                                isCreatingUser = false;
                                console.log("User creation completed, flag reset");
                                
                                return null; // Return null to indicate we've handled this case
                            });
                        } else if (!response.ok) {
                            throw new Error('Failed to fetch user data');
                        } else {
                            return response.json();
                        }
                    })
                    .then(data => {
                        if (data) {
                            console.log("User data loaded from server:", data);
                            
                            // IMPORTANT: Keep existing user data
                            // Do not generate new IDs or usernames if they already exist
                            let needsUpdate = false;
                            
                            // Use the server ID if it exists
                            if (data.gameId) {
                                userId = data.gameId;
                                console.log("Using existing game ID from server:", userId);
                                // Update the local storage
                                localStorage.setItem("tidashUserId", userId);
                            } 
                            // Otherwise, use the stored ID from localStorage if it exists
                            else if (storedUserId) {
                                userId = storedUserId;
                                needsUpdate = true;
                                console.log("Using stored game ID from localStorage:", userId);
                            } 
                            // As a last resort, generate a new ID
                            else {
                                userId = generateRandomUserId();
                                needsUpdate = true;
                                console.log("Generated new game ID as last resort:", userId);
                                localStorage.setItem("tidashUserId", userId);
                            }
                            
                            // Same logic for the username
                            if (data.gameUsername) {
                                username = data.gameUsername;
                                console.log("Using existing username from server:", username);
                                localStorage.setItem("tidashUsername", username);
                            } 
                            else if (storedUsername) {
                                username = storedUsername;
                                needsUpdate = true;
                                console.log("Using stored username from localStorage:", username);
                            } 
                            else {
                                username = generateRandomUsername();
                                needsUpdate = true;
                                console.log("Generated new username as last resort:", username);
                                localStorage.setItem("tidashUsername", username);
                            }
                            
                            // Handle avatar path correctly
                            if (data.avatarSrc) {
                                console.log('Avatar from server:', data.avatarSrc);
                                
                                // Ensure avatar path is absolute and clean (remove any cache parameters)
                                let cleanAvatarSrc = data.avatarSrc;
                                if (cleanAvatarSrc.includes('?')) {
                                    cleanAvatarSrc = cleanAvatarSrc.split('?')[0];
                                }
                                
                                if (cleanAvatarSrc.startsWith('http')) {
                                    avatarSrc = cleanAvatarSrc;
                                } else if (cleanAvatarSrc.startsWith('/')) {
                                    avatarSrc = window.location.origin + cleanAvatarSrc;
                                } else {
                                    avatarSrc = window.location.origin + '/avatars/' + cleanAvatarSrc;
                                }
                                
                                // Add a cache-busting parameter to force image reload
                                avatarSrc = avatarSrc.includes('?') 
                                    ? avatarSrc + '&t=' + new Date().getTime() 
                                    : avatarSrc + '?t=' + new Date().getTime();
                                    
                                console.log('Processed avatar URL:', avatarSrc);
                            } else {
                                // Default avatar with absolute path
                                avatarSrc = window.location.origin + '/avatars/avatar_default.jpg';
                                console.log('No avatar found in server data, using default');
                            }
                            
                            // Keep the other user data
                            paypalEmail = data.paypalEmail || "";
                            bestScore = parseInt(data.bestScore || "0");
                            seasonScore = parseInt(data.seasonScore || "0");
                            
                            // Set music preference from server
                            isMusicEnabled = data.musicEnabled !== undefined ? data.musicEnabled : true;
                            
                            // Only update the server if we needed to update ID or username
                            if (needsUpdate) {
                                console.log("Updating user data on server with preserved information");
                                setTimeout(() => sendUserDataToServer(), 500);
                            } else {
                                console.log("User data is complete, no updates needed");
                            }
                            
                            // Update UI elements
                            updateUserProfileDisplay();
                            updateScoreDisplay();
                            updateSoundToggleDisplay();
                            
                            // Initialize avatar selection
                            initAvatarSelection();
                            
                            // Check for active season
                            checkForNewSeason();
                            
                            // Fetch the current user's season score from the server
                            fetchUserSeasonScore();
                            
                            return data;
                        }
                        
                        // Fallback - Use locally stored data if available
                        if (storedUserId && storedUsername) {
                            console.log("Falling back to stored user data due to server error");
                            userId = storedUserId;
                            username = storedUsername;
                            avatarSrc = window.location.origin + '/avatars/avatar_default.jpg';
                            
                            // Update UI elements
                            updateUserProfileDisplay();
                            updateScoreDisplay();
                            updateSoundToggleDisplay();
                        } else {
                            console.log("No stored data available, creating temporary user");
                            // Create a temporary user
                            userId = generateRandomUserId();
                            username = generateRandomUsername();
                            avatarSrc = window.location.origin + '/avatars/avatar_default.jpg';
                            
                            // Store locally
                            localStorage.setItem("tidashUserId", userId);
                            localStorage.setItem("tidashUsername", username);
                            
                            // Update UI elements
                            updateUserProfileDisplay();
                            updateScoreDisplay();
                            updateSoundToggleDisplay();
                        }
                    })
                    .catch(error => {
                        console.error("Error initializing user profile:", error);
                    });
            } catch (error) {
                console.error("Error in initUserProfile:", error);
                
                // Emergency fallback
                username = generateRandomUsername();
                userId = generateRandomUserId();
                avatarSrc = window.location.origin + '/avatars/avatar_default.jpg';
                
                // Update UI as a last resort
                updateUserProfileDisplay();
            }
        }
        
        // Function to populate the avatar grid
        function populateAvatarGrid() {
            try {
                console.log("Populating avatar grid...");
                const avatarsGrid = document.getElementById('avatars-grid');
                
                // Clear existing avatars
                avatarsGrid.innerHTML = '';
                
                // List of available avatars (using the correct filenames)
                const avatars = [
                    'avatar_default.jpg',
                    'avatar1.jpg',
                    'avatar2.jpg',
                    'avatar3.jpg',
                    'avatar4.jpg',
                    'avatar5.jpg',
                    'avatar6.jpg',
                    'avatar7.jpg',
                    'avatar8.jpg',
                    'avatar9.jpg',
                    'avatar10.jpg',
                    'avatar11.jpg',
                    'avatar12.jpg',
                    'avatar13.jpg',
                    'avatar14.jpg',
                    'avatar15.jpg',
                    'avatar16.jpg',
                    'avatar17.jpg',
                    'avatar18.jpg',
                    'avatar19.jpg',
                    'avatar20.jpg'
                ];
                
                // Create avatar items
                avatars.forEach(avatar => {
                    const avatarItem = document.createElement('div');
                    avatarItem.className = 'avatar-item';
                    
                    const img = document.createElement('img');
                    img.src = `avatars/${avatar}`;
                    img.alt = 'Avatar';
                    
                    const check = document.createElement('div');
                    check.className = 'avatar-check';
                    check.innerHTML = '✓';
                    
                    avatarItem.appendChild(img);
                    avatarItem.appendChild(check);
                    avatarsGrid.appendChild(avatarItem);
                });
                
                console.log(`Added ${avatars.length} avatars to the grid`);
                
                // Initialize avatar selection
                initAvatarSelection();
            } catch (error) {
                console.error("Error populating avatar grid:", error);
            }
        }

        // Function to initialize avatar selection
        function initAvatarSelection() {
            try {
                console.log("Initializing avatar selection...");

                // Get all avatar items
                const avatarItems = document.querySelectorAll('.avatar-item');

                // Clear any existing selected state
                avatarItems.forEach(item => {
                    item.classList.remove('selected');
                });

                // Get current avatar filename (strip query string if present)
                let currentAvatarSrc = avatarSrc;
                let avatarFilename = currentAvatarSrc.split('/').pop();
                avatarFilename = avatarFilename.split('?')[0]; // Remove query string

                console.log(`Looking for avatar: ${avatarFilename}`);

                // Find and select the matching avatar (ignore query string in img.src)
                let found = false;
                avatarItems.forEach(item => {
                    const itemImg = item.querySelector('img');
                    if (itemImg) {
                        let imgFilename = itemImg.src.split('/').pop().split('?')[0];
                        if (imgFilename === avatarFilename) {
                            item.classList.add('selected');
                            found = true;
                            console.log(`Selected avatar: ${itemImg.src}`);
                        }
                    }
                });

                if (!found) {
                    console.log("Matching avatar not found, selecting default");
                    // Select default avatar if no match found
                    const defaultAvatar = document.querySelector('.avatar-item:first-child');
                    if (defaultAvatar) {
                        defaultAvatar.classList.add('selected');
                    }
                }

                // Add click event listeners to avatar items
                avatarItems.forEach(item => {
                    item.addEventListener('click', function() {
                        // Remove selected class from all avatars
                        avatarItems.forEach(avatar => {
                            avatar.classList.remove('selected');
                        });

                        // Add selected class to clicked avatar
                        this.classList.add('selected');

                        // Get the src of the selected avatar (strip query string)
                        let selectedAvatarSrc = this.querySelector('img').src;
                        let avatarFilename = selectedAvatarSrc.split('/').pop().split('?')[0];
                        const avatarPath = '/avatars/' + avatarFilename;
                        console.log('Selected avatar filename:', avatarFilename);

                        // Update avatar in UI with a new cache-busting parameter (remove any existing one first)
                        const cacheBuster = '?t=' + new Date().getTime();
                        const cleanSrc = selectedAvatarSrc.split('?')[0];
                        document.getElementById('settings-avatar').src = cleanSrc + cacheBuster;
                        document.getElementById('avatarImg').src = cleanSrc + cacheBuster;

                        // Update avatarSrc variable with the full path for display
                        avatarSrc = window.location.origin + '/avatars/' + avatarFilename;

                        console.log('Avatar selected (full path):', avatarSrc);

                        // Save to server with a small delay to ensure UI updates first
                        setTimeout(() => {
                            // Force sending avatar filename to server
                            const forceAvatarUpdate = {
                                avatarFilename: avatarFilename
                            };

                            sendUserDataToServer(forceAvatarUpdate)
                                .then(response => {
                                    if (response && response.user) {
                                        console.log('Avatar saved successfully on server:', response.user.avatarSrc);
                                    }
                                });
                        }, 100);

                        console.log(`Avatar updated: ${avatarPath}`);
                    });
                });
            } catch (error) {
                console.error("Error initializing avatar selection:", error);
            }
        }
        
        // Function to update sound toggle display
        function updateSoundToggleDisplay() {
            try {
                const soundToggle = document.querySelector('.sound-toggle');
                if (soundToggle) {
                    if (isMusicEnabled) {
                        soundToggle.classList.remove('muted');
                    } else {
                        soundToggle.classList.add('muted');
                    }
                }
            } catch (error) {
                console.error("Error updating sound toggle display:", error);
            }
        }
        
        // Function to send user data to server
        function sendUserDataToServer(forceUpdate = {}) {
            try {
                console.log("Sending user data to server...");
                
                // Get device ID from cookie
                const deviceId = getCookie("tidashDeviceId") || "";
                
                // Get Telegram data if available
                const telegramId = window.telegramId || "";
                const telegramUsername = window.telegramUsername || "";
                
                // Prepare user data
                const userData = {
                    gameId: userId,
                    gameUsername: username,
                    bestScore: bestScore,
                    seasonScore: seasonScore,
                    // Processing the avatar
                    avatarSrc: (() => {
                        // If a forced avatar update is requested
                        if (forceUpdate.avatarFilename) {
                            console.log('Forced avatar update:', forceUpdate.avatarFilename);
                            return forceUpdate.avatarFilename;
                        }
                        
                        let cleanAvatarSrc = avatarSrc;
                        // Remove cache parameters
                        if (cleanAvatarSrc.includes('?')) {
                            cleanAvatarSrc = cleanAvatarSrc.split('?')[0];
                        }
                        // Extract only the filename if it's a complete path
                        if (cleanAvatarSrc.includes('/avatars/')) {
                            const avatarFilename = cleanAvatarSrc.split('/avatars/').pop();
                            console.log('Sending avatar filename to server:', avatarFilename);
                            return avatarFilename; // Send only the filename
                        }
                        // If it's already just a filename, return it as is
                        if (!cleanAvatarSrc.includes('/') && !cleanAvatarSrc.startsWith('http')) {
                            console.log('Avatar filename already clean:', cleanAvatarSrc);
                            return cleanAvatarSrc;
                        }
                        return cleanAvatarSrc;
                    })(),
                    paypalEmail: paypalEmail,
                    deviceId: deviceId,
                    musicEnabled: isMusicEnabled,
                    telegramId: telegramId,
                    telegramUsername: telegramUsername
                };
                
                console.log("User data to send:", userData);
                
                // Send data to server
                return fetch('/api/users', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(userData)
                })
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Failed to save user data');
                    }
                    return response.json();
                })
                .then(data => {
                    console.log('User data saved successfully:', data);
                    
                    // Update user data from response if available
                    if (data.user) {
                        userId = data.user.gameId || userId;
                        bestScore = parseInt(data.user.bestScore || bestScore);
                        
                        // Update UI
                        updateUserProfileDisplay();
                        updateScoreDisplay();
                    }
                    
                    return data;
                })
                .catch(error => {
                    console.error('Error saving user data:', error);
                });
            } catch (error) {
                console.error("Error in sendUserDataToServer:", error);
            }
        }
        
        // Function to update season info display
        function updateSeasonInfoDisplay() {
            try {
                console.log('Updating season info display...');
                
                // Get the season info container and elements
                const seasonInfoContainer = document.getElementById('season-info-container');
                const seasonNumberElement = document.querySelector('/* .season-number { display: none; } */');
                const seasonPrizeElement = document.querySelector('.season-prize');
                
                if (!seasonInfoContainer || !seasonNumberElement || !seasonPrizeElement) {
                    console.error('Season info elements not found');
                    return;
                }
                
                // Add timestamp to prevent caching
                const timestamp = new Date().getTime();
                
                // Use only the admin endpoint as it's working properly
                fetch(`/api/active-season?_=${timestamp}`)
                .then(response => {
                    if (!response.ok) {
                        if (response.status === 404) {
                            console.log('No active season found');
                            // Even if there is no active season, display the container with default values
                            seasonNumberElement.textContent = 'Season -';
                            seasonPrizeElement.textContent = `- Prize`;
                            
                            return null;
                        }
                        throw new Error(`Error retrieving active season: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    if (!data) return; // Skip if no data
                    
                    console.log('Season data received from admin endpoint:', data);
                    
                    // Get season number and prize money
                    const seasonNumber = data.seasonNumber || 1;
                    const prizeMoney = data.prizeMoney || 500;
                    
                    console.log(`Updating season display: Season ${seasonNumber}, Prize $${prizeMoney}`);
                    
                    // Update the elements
                    seasonNumberElement.textContent = `Season ${seasonNumber}`;
                    seasonPrizeElement.textContent = `$${prizeMoney} Prize 🥇`;
                    
                    // Show the container
                    seasonInfoContainer.style.display = 'block';
                })
                .catch(error => {
                    console.error('Error updating season info display:', error);
                    // Even in case of error, display the container with default values
                    seasonNumberElement.textContent = 'Season -';
                    seasonPrizeElement.textContent = `- Prize`;
                });
            } catch (error) {
                console.error('Error in updateSeasonInfoDisplay:', error);
            }
        }
        
        // Function to check for new season
        function checkForNewSeason(forceReset = false) {
            try {
                console.log("Checking for active season...");
                
                fetch('/api/seasons/active')
                .then(response => {
                    if (!response.ok) {
                        if (response.status === 404) {
                            return null;
                        }
                        throw new Error('Error retrieving active season');
                    }
                    return response.json();
                })
                .then(data => {
                    if (!data) {
                        console.log("No active season, keeping existing season score: " + seasonScore);
                        // Still update any UI elements with the current seasonScore value
                        updateScoreDisplay();
                        return seasonScore;
                    }
                    
                    console.log(`Active season found: ${data.id}, Season ${data.seasonNumber}`);
                    
                    // Get user's score for this season
                    return fetch(`/api/seasons/${data.id}/scores/${userId}`)
                    .then(response => response.ok ? response.json() : { score: 0 })
                    .then(serverData => {
                        // Use the server's score as the source of truth
                        let serverSeasonBest = serverData && serverData.score ? parseInt(serverData.score) : 0;
                        
                        console.log(`Game Over - Current game score: ${score}, Server season best: ${serverSeasonBest}`);
                        
                        // IMPORTANT FIX: Always check if we need to update the season score
                        // We need to handle two cases:
                        // 1. If this is the first game in a new season, we should send the score regardless
                        // 2. If the current score is better than the stored season best
                        
                        // Check with the server if this is a new season for the user
                        const isFirstGame = serverSeasonBest === 0;
                        
                        if (isFirstGame || score > serverSeasonBest) {
                            // Update our local variable
                            if (score > serverSeasonBest) {
                                seasonScore = score;
                                console.log(`New season best achieved: ${seasonScore}`);
                            } else {
                                console.log(`First game in new season: ${score}`);
                                // Even if it's not a personal best, we need to record it for the first game
                                seasonScore = score;
                            }
                            
                            // Send updated score to server immediately
                            sendUserDataToServer();
                        } else {
                            // If we didn't update the score, make sure we're using the server's value
                            seasonScore = serverSeasonBest;
                        }
                        
                        // CRITICAL FIX: Always display the season score, regardless of whether it was updated
                        // This ensures the season score is always visible in the game over popup
                        const seasonScoreElement = document.getElementById('season-score');
                        if (seasonScoreElement) {
                            seasonScoreElement.textContent = `Season ${data.seasonNumber} Best: ${seasonScore} 🏆`;
                            seasonScoreElement.style.display = 'block';
                        }
                    })
                    .catch(error => {
                        console.error('Error getting season score from server:', error);
                        // Fallback to local data if server request fails
                        const seasonScoreElement = document.getElementById('season-score');
                        if (seasonScoreElement) {
                            seasonScoreElement.textContent = `Season ${data.seasonNumber} Best: ${score} 🏆`;
                            seasonScoreElement.style.display = 'block';
                        }
                    });
                })
                .catch(error => {
                    console.error('Error checking active season:', error);
                    const seasonScoreElement = document.getElementById('season-score');
                    if (seasonScoreElement) {
                        seasonScoreElement.style.display = 'none';
                    }
                });
            } catch (error) {
                console.error("Error in checkForNewSeason:", error);
            }
        }
        
        // Helper function to get cookie value
        function getCookie(name) {
            const value = `; ${document.cookie}`;
            const parts = value.split(`; ${name}=`);
            if (parts.length === 2) return parts.pop().split(';').shift();
            return null;
        }
        
        // Helper function to set cookie
        function setCookie(name, value, days) {
            let expires = "";
            if (days) {
                const date = new Date();
                date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
                expires = "; expires=" + date.toUTCString();
            }
            document.cookie = name + "=" + (value || "") + expires + "; path=/; SameSite=Strict";
        }
        
        // Function to update user profile display
        function updateUserProfileDisplay() {
            try {
                // Update username
                document.getElementById('username').textContent = username;
                
                // Update user ID
                document.getElementById('userId').textContent = userId;
                
                // Ensure avatar path is valid and add cache-busting parameter
                let avatarUrl = avatarSrc;
                
                // If the avatar doesn't have a cache parameter, add one
                if (!avatarUrl.includes('?')) {
                    avatarUrl += '?t=' + new Date().getTime();
                }
                
                console.log('Updating the avatar in the interface:', avatarUrl);
                
                // Update avatar
                document.getElementById('avatarImg').src = avatarUrl;
                document.getElementById('settings-avatar').src = avatarUrl;
                
                // Update settings fields
                const usernameInput = document.getElementById('username-input');
                if (usernameInput) {
                    usernameInput.value = username;
                    usernameInput.placeholder = username;
                }
                
                const paypalInput = document.getElementById('paypal-email');
                if (paypalInput) {
                    paypalInput.value = paypalEmail || '';
                    paypalInput.placeholder = paypalEmail || 'TAbCdEfG...wXyZ1234';
                }
                
                const settingsUserId = document.getElementById('settings-user-id');
                if (settingsUserId) {
                    settingsUserId.textContent = userId;
                }
            } catch (error) {
                console.error("Error updating user profile display:", error);
            }
        }
        
        // Function to update score display
        function updateScoreDisplay() {
            try {
                // Update best score
                document.getElementById('best-score').textContent = `Best: ${bestScore}`;
                
                // Update season score - simple value without emoji or image
                const seasonScoreElement = document.getElementById('season-score');
                if (seasonScoreElement) {
                    // Just display the raw score value
                    seasonScoreElement.textContent = `Season Best: ${seasonScore}`;
                }
            } catch (error) {
                console.error("Error updating score display:", error);
            }
        }
        
        // Function to fetch the current user's season score from the server
        function fetchUserSeasonScore() {
            console.log("Fetching user's season score from server (enhanced version)...");
            
            // Check that the user is correctly initialized
            if (!userId) {
                console.warn("Cannot fetch season score - userId is not defined");
                return Promise.resolve(0);
            }
            
            // DIRECT IMPLEMENTATION of leaderboard approach - fetch season ranking and find user's score
            return fetch('/api/seasons/active')
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Error retrieving active season');
                    }
                    return response.json();
                })
                .then(season => {
                    console.log(`Active season found: ${season.id}, Season ${season.seasonNumber}`);
                    
                    // Get the user's score directly
                    return fetch(`/api/seasons/${season.id}/scores/${encodeURIComponent(userId)}`)
                        .then(response => {
                            if (response.ok) {
                                return response.json();
                            } else {
                                // If the score API fails, return a default score
                                console.log(`Unable to retrieve the season score, using default value`);
                                return { score: 0 };
                            }
                        })
                        .then(scoreData => {
                            // Extract the score
                            const serverSeasonScore = scoreData.score || 0;
                            console.log(`Season score retrieved: ${serverSeasonScore}`);
                            
                            // Get the user's position (rank) for display
                            // Determine the base URL with the correct path
                            let baseUrl = window.location.origin;
                            
                            // Check if we are in the /test path
                            const pathname = window.location.pathname;
                            const basePathMatch = pathname.match(/^\/([^\/]+)/);
                            const basePath = basePathMatch ? basePathMatch[1] : '';
                            
                            if (basePath) {
                                console.log(`Detection of a base path: /${basePath}`);
                                // Add the base path to the URL
                                baseUrl = `${baseUrl}/${basePath}`;
                            }
                            
                            console.log(`Base URL determined for rank request: ${baseUrl}`);
                            
                            // Complete URL with the correct base path
                            const rankApiUrl = `${baseUrl}/api/seasons/${season.id}/user-position?userId=${encodeURIComponent(userId)}`;
                            console.log(`API rank URL: ${rankApiUrl}`);
                            
                            console.log(`Sending request for rank...`);
                            return fetch(rankApiUrl, {
                                method: 'GET',
                                headers: {
                                    'Accept': 'application/json',
                                    'Cache-Control': 'no-cache'
                                }
                            })
                                .then(rankResponse => {
                                    console.log(`Rank response status: ${rankResponse.status} ${rankResponse.statusText}`);
                                    
                                    // Even if the position request fails, we already have the score
                                    if (rankResponse.ok) {
                                        return rankResponse.text().then(responseText => {
                                            console.log(`Raw rank response: ${responseText}`);
                                            
                                            try {
                                                const rankData = JSON.parse(responseText);
                                                console.log(`Parsed rank data:`, rankData);
                                                
                                                if (rankData && rankData.hasOwnProperty('position')) {
                                                    console.log(`Position user retrieved: ${rankData.position}`);
                                                    return {
                                                        score: serverSeasonScore,
                                                        position: rankData.position
                                                    };
                                                } else {
                                                    console.warn(`Rank response does not contain 'position' property:`, rankData);
                                                    return { score: serverSeasonScore, position: '-' };
                                                }
                                            } catch (parseError) {
                                                console.error(`Error parsing JSON:`, parseError);
                                                console.log(`Response is not a valid JSON`);
                                                return { score: serverSeasonScore, position: '-' };
                                            }
                                        });
                                    } else {
                                        try {
                                            return rankResponse.text().then(errorText => {
                                                console.error(`API rank error (${rankResponse.status}): ${errorText}`);
                                                return { score: serverSeasonScore, position: '-' };
                                            });
                                        } catch (e) {
                                            console.error(`HTTP error for rank: ${rankResponse.status} ${rankResponse.statusText}`);
                                            return { score: serverSeasonScore, position: '-' };
                                        }
                                    }
                                })
                                .catch(error => {
                                    console.error('Error fetching rank:', error);
                                    return { score: serverSeasonScore, position: '-' };
                                })
                                .then(data => {
                                    // Update the global variable with the score
                                    seasonScore = data.score;
                                    
                                    // Update UI elements with the score and position
                            const seasonScoreElement = document.getElementById('season-score');
                            if (seasonScoreElement) {
                                seasonScoreElement.textContent = `Season Best: ${seasonScore}`;
                                        // Store the position as a data attribute for later use
                                        seasonScoreElement.setAttribute('data-position', data.position);
                            }
                                    
                                    // Display the position in the console for verification
                                    console.log('%c User position (fetchUserSeasonScore): ' + data.position, 'font-size: 24px; color: red; background-color: yellow;');
                                    
                            return seasonScore;
                                });
                        });
                })
                .catch(error => {
                    console.error("Error in enhanced fetchUserSeasonScore:", error);
                    // Don't reset seasonScore on error, return current value
                    return Promise.resolve(seasonScore);
                });
        }
        
        // Initialize the game
        document.addEventListener('DOMContentLoaded', function() {
            console.log("Game initialization starting...");
            
            // CRITICAL FIX FOR SEASON SCORE: Set up a forced refresh interval for season scores
            // This ensures the score is always fetched fresh before displaying the game over screen
            function refreshSeasonScore() {
                if (userId) {
                    console.log("Forcing season score refresh from server...");
                    fetchUserSeasonScore()
                        .then(score => console.log("Season score refreshed: " + score))
                        .catch(err => console.error("Season score refresh failed", err));
                }
            }
            
            // Immediately initialize the season score
            setTimeout(refreshSeasonScore, 500);
            
            // Refresh the season score every 30 seconds to ensure it's always current
            setInterval(refreshSeasonScore, 30000);
            
            // Initialize canvas dimensions
            resizeCanvas();
            
            // Initialize stars
            initStars();
            
            // Populate avatar grid
            populateAvatarGrid();

            // Load user profile
            initUserProfile();
            
            // Send user data to server for admin panel
            sendUserDataToServer();
            
            // Initialize and display season information
            updateSeasonInfoDisplay();
            
            // Set up periodic refresh for season information (every 30 seconds)
            setInterval(updateSeasonInfoDisplay, 30000);
            
            // Fetch the season score before any other initialization
            fetchUserSeasonScore();
            
            // Initialize stars
            initStars();
            
            // Populate avatar grid
            populateAvatarGrid();

            // Load user profile
            initUserProfile();
            
            // Send user data to server for admin panel
            sendUserDataToServer();
            
            // Initialize and display season information
            updateSeasonInfoDisplay();
            
            // Set up periodic refresh for season information (every 30 seconds)
            setInterval(updateSeasonInfoDisplay, 30000);
            
            // Function to create particles around the season container
            function createParticles() {
                const particlesContainer = document.getElementById('particles');
                if (!particlesContainer) return;
                
                // Clear the container
                particlesContainer.innerHTML = '';
                
                // Create 20 particles
                for (let i = 0; i < 20; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'particle';
                    
                    // Random position within the container
                    const x = Math.random() * 100;
                    const y = Math.random() * 100;
                    particle.style.left = `${x}%`;
                    particle.style.top = `${y}%`;
                    
                    // Random direction for animation
                    const xDirection = (Math.random() - 0.5) * 100;
                    const yDirection = (Math.random() - 0.5) * 100;
                    particle.style.setProperty('--x', `${xDirection}px`);
                    particle.style.setProperty('--y', `${yDirection}px`);
                    
                    // Random delay for animation
                    particle.style.animationDelay = `${Math.random() * 3}s`;
                    
                    particlesContainer.appendChild(particle);
                }
            }
            
            // Create initial particles
            createParticles();
            
            // Recreate particles every 6 seconds for a continuous effect
            setInterval(createParticles, 6000);
            
            // Function to retrieve and display active season data
            function updateSeasonContainer(forceRefresh = false) {
                // Retrieve DOM elements
                const seasonPrizeElement = document.querySelector('.season-prize');
                const seasonNameElement = document.querySelector('.season-name');
                
                if (!seasonPrizeElement || !seasonNameElement) return;
                
                // Indicate that data is being loaded
                seasonPrizeElement.setAttribute('data-loading', 'true');
                seasonNameElement.setAttribute('data-loading', 'true');
                
                // Add a cache-busting parameter to force a new request each time
                const timestamp = new Date().getTime();
                
                console.log(`Synchronizing season data... (${timestamp})`);
                
                // Build the complete API path with protocol and domain
                // This ensures the API is called on the same server as the one hosting the application
                const apiPath = window.location.pathname.includes('/public/') 
                    ? '../api/seasons/active' // Relative path if we are in /public/
                    : '/api/seasons/active';  // Absolute path otherwise
                
                console.log(`API path used: ${apiPath}`);
                
                // Add the timestamp as a query parameter to avoid caching
                const url = `${apiPath}?_=${timestamp}${forceRefresh ? '&force=true' : ''}`;
                
                // Display the complete URL for debugging
                console.log(`Request URL: ${url}`);
                
                // Define a shorter timeout for the request (3 seconds)
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 3000);
                
                // Add a direct request to the SQLite database
                // The path to the database is /var/lib/tidash_database.sqlite
                console.log('SQLite database path: /var/lib/tidash_database.sqlite');
                
                // Retrieve active season data from the API with cache-busting
                fetch(url, {
                    method: 'GET',
                    headers: {
                        'Cache-Control': 'no-cache, no-store, must-revalidate',
                        'Pragma': 'no-cache',
                        'Expires': '0',
                        'Accept': 'application/json',
                        'X-Requested-With': 'XMLHttpRequest' // Add this header to identify AJAX requests
                    },
                    credentials: 'include', // Use 'include' instead of 'same-origin' for cross-origin cookies
                    signal: controller.signal,
                    cache: 'no-store' // Force not to use browser cache
                })
                    .then(response => {
                        clearTimeout(timeoutId);
                        
                        console.log(`Response received: Status ${response.status}`);
                        
                        // Display response headers for debugging
                        response.headers.forEach((value, name) => {
                            console.log(`Header: ${name} = ${value}`);
                        });
                        
                        if (!response.ok) {
                            throw new Error(`API error (Status: ${response.status})`);
                        }
                        
                        // Check if the response is empty
                        const contentType = response.headers.get('content-type');
                        if (!contentType || !contentType.includes('application/json')) {
                            throw new Error(`Invalid content type: ${contentType}`);
                        }
                        
                        return response.json().catch(error => {
                            throw new Error(`JSON parsing error: ${error.message}`);
                        });
                    })
                    .then(data => {
                        // Display raw data for debugging
                        console.log('Received data:', JSON.stringify(data));
                        
                        // Check if the data is valid
                        if (!data) {
                            throw new Error('Empty data received from API');
                        }
                        
                        // Extract season data, accounting for different possible formats
                        let seasonId, seasonNumber, prizeMoney;
                        
                        if (data.id || data.seasonId) {
                            seasonId = data.id || data.seasonId;
                            seasonNumber = data.seasonNumber || data.season_number || 0;
                            prizeMoney = data.prizeMoney || data.prize_money || 000;
                            
                            // Display active season information
                            console.log(`Active season found: ID=${seasonId}, Saison=${seasonNumber}, Prix=$${prizeMoney}`);
                            
                            // Mark elements as loaded
                            seasonPrizeElement.removeAttribute('data-loading');
                            seasonNameElement.removeAttribute('data-loading');
                            
                            // Force values to be strings
                            const prizeMoneyStr = String(prizeMoney);
                            const seasonNumberStr = String(seasonNumber);
                            
                            // Update the prize text immediately
                            console.log(`Update prize: $${prizeMoneyStr}`);
                            seasonPrizeElement.textContent = `🏆$${prizeMoneyStr}🏆`;
                            
                            // Update the season name immediately
                            console.log(`Update season name: ${seasonNumberStr}`);
                            seasonNameElement.textContent = `Season ${seasonNumberStr}`;
                            
                            // Store season data in localStorage for persistence
                            try {
                                const dataToStore = {
                                    id: seasonId,
                                    seasonNumber: seasonNumberStr,
                                    prizeMoney: prizeMoneyStr,
                                    timestamp: timestamp,
                                    lastUpdated: new Date().toISOString()
                                };
                                localStorage.setItem('activeSeasonData', JSON.stringify(dataToStore));
                                console.log('Season data saved to localStorage');
                                
                                // Remove data-loading attribute to stop animation
                                seasonPrizeElement.removeAttribute('data-loading');
                                seasonNameElement.removeAttribute('data-loading');
                            } catch (e) {
                                console.error('Error storing season data:', e);
                            }
                        } else {
                            console.warn('Invalid season data:', data);
                            
                            // Use default values that you specified
                            seasonPrizeElement.removeAttribute('data-loading');
                            seasonNameElement.removeAttribute('data-loading');
                            seasonPrizeElement.textContent = '-';
                            seasonNameElement.textContent = 'Season 0';
                            
                            throw new Error('Invalid season data or incomplete');
                        }
                    })
                    .catch(error => {
                        console.error('Error fetching season data:', error.message);
                        
                        // Directly access the SQLite database (via an alternative API)
                        console.log('Attempting direct access to the SQLite database...');
                        
                        // Try with an absolute direct URL with a special parameter to force refresh
                        const directDbUrl = `${window.location.origin}/api/seasons/active?_=${Date.now()}&direct=true`;
                        console.log(`Direct database access URL: ${directDbUrl}`);
                        
                        return fetch(directDbUrl, {
                            method: 'GET',
                            headers: {
                                'Cache-Control': 'no-cache, no-store, must-revalidate',
                                'Pragma': 'no-cache',
                                'Expires': '0',
                                'Accept': 'application/json',
                                'X-Direct-DB-Access': 'true',
                                'X-DB-Path': '/var/lib/tidash_database.sqlite'
                            },
                            credentials: 'include',
                            cache: 'no-store'
                        })
                        .then(response => {
                            if (!response.ok) {
                                throw new Error(`Error accessing the database (Status: ${response.status})`);
                            }
                            return response.json();
                        })
                        .then(data => {
                            console.log('Data retrieved via direct access:', data);
                            
                            // Mark elements as loaded
                            seasonPrizeElement.removeAttribute('data-loading');
                            seasonNameElement.removeAttribute('data-loading');
                            
                            // Extract season data, accounting for different possible formats
                            let seasonId, seasonNumber, prizeMoney;
                            
                            if (data.id || data.seasonId) {
                                seasonId = data.id || data.seasonId;
                                seasonNumber = data.seasonNumber || data.season_number || 2;
                                prizeMoney = data.prizeMoney || data.prize_money || 200;
                                
                                // Force values to be strings
                                const prizeMoneyStr = String(prizeMoney);
                                const seasonNumberStr = String(seasonNumber);
                                
                                // Update the prize text immediately
                                seasonPrizeElement.textContent = `🏆$${prizeMoneyStr}🏆`;
                                
                                // Update the season name immediately
                                seasonNameElement.textContent = `Season ${seasonNumberStr}`;
                                
                                // Save in the cache
                                try {
                                    const dataToStore = {
                                        id: seasonId,
                                        seasonNumber: seasonNumberStr,
                                        prizeMoney: prizeMoneyStr,
                                        timestamp: Date.now(),
                                        source: 'direct-db-access'
                                    };
                                    localStorage.setItem('activeSeasonData', JSON.stringify(dataToStore));
                                    console.log('Data saved to localStorage (direct access)');
                                } catch (e) {
                                    console.warn('Failed to store direct access data', e);
                                }
                            } else {
                                throw new Error('Invalid direct access data');
                            }
                        })
                        .catch(directDbError => {
                            console.error('Error with direct database access:', directDbError.message);
                            
                            // Use the most recent values from the admin
                            console.log('Using the most recent values from the admin...');
                            
                            // Stop the loading animation
                            seasonPrizeElement.removeAttribute('data-loading');
                            seasonNameElement.removeAttribute('data-loading');
                            
                            // Define the values you specified
                            seasonPrizeElement.textContent = '🏆$000🏆';
                            seasonNameElement.textContent = 'Season 0';
                            
                            // Save these values in the cache
                            try {
                                const hardcodedData = {
                                    id: 'admin-override',
                                    seasonNumber: '2',
                                    prizeMoney: '200',
                                    timestamp: Date.now(),
                                    source: 'admin-override'
                                };
                                localStorage.setItem('activeSeasonData', JSON.stringify(hardcodedData));
                                console.log('Values saved to localStorage (admin override)');
                            } catch (e) {
                                console.warn('Failed to store admin override values', e);
                            }
                        });
                    });
            }
            
            // Add a style for the update animation and loading state
            const style = document.createElement('style');
            style.textContent = `
                .season-prize.updating, .season-name.updating {
                    opacity: 0.5;
                    transition: opacity 0.3s ease;
                }
                
                .season-prize[data-loading="true"], .season-name[data-loading="true"] {
                    opacity: 0.7;
                    animation: pulse 1.5s infinite ease-in-out;
                }
                
                @keyframes pulse {
                    0% { opacity: 0.5; }
                    50% { opacity: 0.8; }
                    100% { opacity: 0.5; }
                }
            `;
            document.head.appendChild(style);
            
            // Function to force a complete refresh of season data
            function forceSeasonRefresh() {
                console.log('Forcing season data refresh...');
                // Remove cached data
                localStorage.removeItem('activeSeasonData');
                localStorage.removeItem('lastSeasonUpdate');
                // Force update
                updateSeasonContainer(true);
            }
            
            // Function to initialize season data
            function initSeasonData() {
                console.log('Initializing season data...');
                
                // Define default values immediately (to show something during loading)
                const seasonPrizeElement = document.querySelector('.season-prize');
                const seasonNameElement = document.querySelector('.season-name');
                
                if (seasonPrizeElement && seasonNameElement) {
                    // Stop the loading animation immediately
                    seasonPrizeElement.removeAttribute('data-loading');
                    seasonNameElement.removeAttribute('data-loading');
                    
                    // Update default values according to your request
                    seasonPrizeElement.textContent = '🏆$000🏆';
                    seasonNameElement.textContent = 'Season 0';
                    
                    // Save these values in the cache
                    try {
                        const hardcodedData = {
                            id: 'default-values',
                            seasonNumber: '0',
                            prizeMoney: '000',
                            timestamp: Date.now(),
                            source: 'initialization'
                        };
                        localStorage.setItem('activeSeasonData', JSON.stringify(hardcodedData));
                        console.log('Default values saved to localStorage');
                    } catch (e) {
                        console.warn('Failed to store default values', e);
                    }
                }
                
                // Update the season container immediately
                updateSeasonContainer(true); // Force refresh on initial load
                
                // Refresh season data every 2 seconds to ensure they are up to date
                const normalRefreshInterval = setInterval(updateSeasonContainer, 2000);
                
                // Force a full refresh every 10 seconds
                const forceRefreshInterval = setInterval(forceSeasonRefresh, 10000);
                
                // Add an event listener for window focus
                window.addEventListener('focus', function() {
                    console.log('Window focused - Refreshing season data');
                    forceSeasonRefresh();
                });
                
                // Add an event listener for clicks on the season container
                const seasonContainer = document.querySelector('.season-container');
                if (seasonContainer) {
                    seasonContainer.addEventListener('click', function() {
                        console.log('Click on the season container – Forced refresh');
                        forceSeasonRefresh();
                    });
                }
                
                return {
                    normalRefreshInterval,
                    forceRefreshInterval
                };
            }
            
            // Initialize season data
            const seasonRefreshIntervals = initSeasonData();
            
            // Initialize Telegram WebApp if available
            if (window.Telegram && window.Telegram.WebApp) {
                console.log("Telegram WebApp detected, initializing...");
                try {
                    const tgWebApp = window.Telegram.WebApp;
                    
                    // Check if we have user data directly from the WebApp
                    if (tgWebApp.initDataUnsafe && tgWebApp.initDataUnsafe.user) {
                        const tgUser = tgWebApp.initDataUnsafe.user;
                        console.log("Telegram user data from WebApp:", tgUser);
                        
                        // Store Telegram user data for later use
                        window.telegramId = tgUser.id?.toString() || "";
                        window.telegramUsername = tgUser.username || "";
                        
                        console.log(`Telegram ID: ${window.telegramId}, Username: ${window.telegramUsername}`);
                    } else {
                        // Fallback to parsing initData string
                        const tgData = tgWebApp.initData || "";
                        if (tgData) {
                            console.log("Parsing Telegram initData string");
                            try {
                                // Parse the initData to get user information
                                const urlParams = new URLSearchParams(tgData);
                                const userParam = urlParams.get('user');
                                if (userParam) {
                                    const tgUser = JSON.parse(decodeURIComponent(userParam));
                                    console.log("Telegram user data from initData:", tgUser);
                                    
                                    // Store Telegram user data for later use
                                    window.telegramId = tgUser.id?.toString() || "";
                                    window.telegramUsername = tgUser.username || "";
                                    
                                    console.log(`Telegram ID: ${window.telegramId}, Username: ${window.telegramUsername}`);
                                }
                            } catch (parseError) {
                                console.error("Error parsing Telegram initData:", parseError);
                            }
                        }
                    }
                    
                    // Set up Telegram WebApp event handlers
                    tgWebApp.onEvent('viewportChanged', function() {
                        console.log("Telegram viewport changed, resizing canvas...");
                        resizeCanvas();
                    });
                    
                    // Expand the WebApp to its maximum size
                    tgWebApp.expand();
                } catch (error) {
                    console.error("Error initializing Telegram WebApp:", error);
                }
            }
            
            // Setup sound toggle
            const soundToggle = document.querySelector('.sound-toggle');
            if (soundToggle) {
                soundToggle.addEventListener('click', function() {
                    // Toggle music state
                    isMusicEnabled = !isMusicEnabled;
                    
                    // Update UI
                    if (isMusicEnabled) {
                        soundToggle.classList.remove('muted');
                        playBackgroundMusic();
                    } else {
                        soundToggle.classList.add('muted');
                        stopBackgroundMusic();
                    }
                    
                    // Save preference to server
                    saveSoundPreference(isMusicEnabled);
                });
            }
            
            // Setup game event listeners
            playAgainBtn.addEventListener('click', resetGame);
            homeBtn.addEventListener('click', goToHome);
            
            // Setup revive button
            reviveBtn.addEventListener('click', function() {
                console.log("Revive button clicked, showing rewarded ad...");
                
                // Disable the button during ad loading
                reviveBtn.disabled = true;
                
                // Show Monetag ad
                if (typeof show_9302441 === 'function') {
                    show_9302441().then(() => {
                        console.log("Ad viewed successfully, reviving player!");
                        
                        // Mark that the player has used Revive
                        hasUsedRevive = true;
                        
                        // Hide the game over screen
                        hideGameOver();
                        
                        // Show a Play overlay on the canvas after the ad
                        const canvasContainer = document.getElementById('game-canvas').parentElement;
                        let overlay = document.createElement('div');
                        overlay.id = 'revive-play-overlay';
                        overlay.style.position = 'absolute';
                        overlay.style.top = 0;
                        overlay.style.left = 0;
                        overlay.style.width = '100%';
                        overlay.style.height = '100%';
                        overlay.style.display = 'flex';
                        overlay.style.alignItems = 'center';
                        overlay.style.justifyContent = 'center';
                        overlay.style.background = 'rgba(0,0,0,0.25)';
                        overlay.style.zIndex = 10000;

                        // Create the Play button
                        let playBtn = document.createElement('button');
                        playBtn.style.background = 'linear-gradient(135deg, #00FF9D 0%, #00C853 100%)';
                        playBtn.style.border = 'none';
                        playBtn.style.borderRadius = '50%';
                        playBtn.style.width = '80px';
                        playBtn.style.height = '80px';
                        playBtn.style.display = 'flex';
                        playBtn.style.alignItems = 'center';
                        playBtn.style.justifyContent = 'center';
                        playBtn.style.boxShadow = '0 4px 24px rgba(0,0,0,0.18)';
                        playBtn.style.cursor = 'pointer';
                        playBtn.setAttribute('aria-label', 'Reprendre');

                        // SVG Play icon
                        playBtn.innerHTML = `<svg width="48" height="48" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="24" cy="24" r="24" fill="#00FF9D"/><path d="M18 15V33L34 24L18 15Z" fill="#121212"/></svg>`;
                        playBtn.addEventListener('click', function() {
                            resumeGameAfterRevive();
                        });

                        overlay.appendChild(playBtn);
                        canvasContainer.appendChild(overlay);

                        // Reactivate the button (for next time)
                        reviveBtn.disabled = false;
                    }).catch(error => {
                        console.error("Error showing ad:", error);
                        // Reactivate the button in case of error
                        reviveBtn.disabled = false;
                    });
                } else {
                    console.error("Monetag function not available");
                    alert("Ad service not available. Please try again later.");
                    reviveBtn.disabled = false;
                }
            });
            
            // Setup profile button
            const profileButton = document.getElementById('profile-button');
            if (profileButton) {
                profileButton.addEventListener('click', function() {
                    // Show settings screen
                    document.getElementById('settings-screen').style.display = 'block';
                });
            }
            
            // Setup settings close button
            const closeSettingsBtn = document.getElementById('close-settings');
            if (closeSettingsBtn) {
                closeSettingsBtn.addEventListener('click', function() {
                    // Hide settings screen
                    document.getElementById('settings-screen').style.display = 'none';
                });
            }
            
            // Setup username input
            const usernameInput = document.getElementById('username-input');
            if (usernameInput) {
                usernameInput.addEventListener('change', function() {
                    // Update username
                    username = this.value;
                    document.getElementById('username').textContent = username;
                    
                    // Save to server
                    sendUserDataToServer();
                });
            }
            
            // Setup PayPal email input
            const paypalEmailInput = document.getElementById('paypal-email');
            if (paypalEmailInput) {
                paypalEmailInput.addEventListener('change', function() {
                    // Update PayPal email
                    paypalEmail = this.value;
                    
                    // Save to server
                    sendUserDataToServer();
                });
            }
            
            // Initialize the game correctly by calling the initGame() function
            // instead of simply defining some variables
            initGame();
            
            // Note: initGame() already takes care of defining gameMode, starting the game loop, etc.
            // so we don't need to do it here
        });
        
        // Function to manage background music
        function manageBackgroundMusic() {
            if (isMusicEnabled) {
                playBackgroundMusic();
            } else {
                stopBackgroundMusic();
            }
        }

        // Function to play background music
        function playBackgroundMusic() {
            try {
                if (!isMusicEnabled) return;
                var backgroundMusicElement = document.getElementById('backgroundMusic');
                if (!backgroundMusicElement) return;

                // Only start a new track if not already playing
                if (!backgroundMusicElement.paused && !backgroundMusicElement.ended && backgroundMusicElement.currentTime > 0) {
                    // Music is already playing, do not restart or change track
                    return;
                }

                // Pick a random music if none is selected or if called for next track
                let newIndex = currentMusicIndex;
                if (homeMusics.length > 1) {
                    // Ensure a different track is played
                    let attempts = 0;
                    while (newIndex === currentMusicIndex && attempts < 10) {
                        newIndex = Math.floor(Math.random() * homeMusics.length);
                        attempts++;
                    }
                } else {
                    newIndex = 0;
                }
                currentMusicIndex = newIndex;
                backgroundMusicElement.src = homeMusics[currentMusicIndex];
                backgroundMusicElement.volume = 0.3;
                const playPromise = backgroundMusicElement.play();
                if (playPromise !== undefined) {
                    playPromise.catch(error => {
                        console.log('Autoplay prevented:', error);
                        window.musicPendingAutoplay = true;
                    });
                }
            } catch (error) {
                console.error('Error playing background music:', error);
            }
        }

        // Ensure next random track is played after one ends
        (function setupMusicRandomizer() {
            document.addEventListener('DOMContentLoaded', function() {
                var backgroundMusicElement = document.getElementById('backgroundMusic');
                if (backgroundMusicElement) {
                    backgroundMusicElement.addEventListener('ended', function() {
                        // Play a different random track only when the previous one ends
                        playBackgroundMusic();
                    });
                }
            });
        })();

        // Function to stop background music
        function stopBackgroundMusic() {
            try {
                const backgroundMusicElement = document.getElementById('backgroundMusic');
                if (backgroundMusicElement && !backgroundMusicElement.paused) {
                    backgroundMusicElement.pause();
                }
            } catch (error) {
                console.error('Error stopping background music:', error);
            }
        }
        
        // Function to save sound preference to server
        function saveSoundPreference(enabled) {
            try {
                // Send preference to server
                fetch('/api/users/preferences', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        userId: userId,
                        musicEnabled: enabled
                    })
                })
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Failed to save sound preference');
                    }
                    return response.json();
                })
                .then(data => {
                    console.log('Sound preference saved:', data);
                })
                .catch(error => {
                    console.error('Error saving sound preference:', error);
                });
            } catch (error) {
                console.error('Error in saveSoundPreference:', error);
            }
        }
        
        // Function to load sound preference from server
        function loadSoundPreference() {
            try {
                if (!userId) return;
                
                // Get preference from server
                fetch(`/api/users/${userId}/preferences`)
                    .then(response => {
                        if (!response.ok) {
                            if (response.status === 404) {
                                return { musicEnabled: false };
                            }
                            throw new Error('Failed to load sound preference');
                        }
                        return response.json();
                    })
                    .then(data => {
                        if (data && data.musicEnabled !== undefined) {
                            isMusicEnabled = data.musicEnabled;
                            userPrefersMusicEnabled = data.musicEnabled;
                            
                            // Update UI
                            const soundToggleBtn = document.getElementById('sound-toggle');
                            if (soundToggleBtn) {
                                soundToggleBtn.classList.toggle('muted', !isMusicEnabled);
                            }
                            
                            // Update music playback
                            if (isMusicEnabled && gameMode === 'home') {
                                playBackgroundMusic();
                            }
                        }
                    })
                    .catch(error => {
                        console.error('Error loading sound preference:', error);
                    });
            } catch (error) {
                console.error('Error in loadSoundPreference:', error);
            }
        }

        // Function to handle game over
        function handleGameOver() {
            console.log("Game over - Score final: " + score);
            
            // Update the best score global
            if (score > bestScore) {
                bestScore = score;
                saveBestScore();
            }
            
            // Change the game state to game over
            gameMode = 'gameOver';
            gameOverAnimation = true;
            gameOverAnimationComplete = false;
            
            // Show or hide the Revive button based on previous usage and score
            if (hasUsedRevive || score === 0) {
                // The player has already used Revive or the score is 0, hide the button
                reviveBtn.style.display = 'none';
                document.getElementById('revive-x2-tipoints').style.display = 'none';
            } else {
                // The player has not yet used Revive and has a score > 0, show the button
                reviveBtn.style.display = 'flex';
                document.getElementById('revive-x2-tipoints').style.display = 'block';
            }
            
            // CRITIQUE: Always retrieve the most recent season score from the server
            // before displaying the game over screen
            fetchUserSeasonScore()
                .then(() => {
                    // Display the game over screen with the updated season score
                    showGameOverScreen();
                })
                .catch(error => {
                    console.error("Error fetching season score:", error);
                    // Even in case of error, display the screen
                    showGameOverScreen();
                });
        }

        // Function to manage background music
        function manageBackgroundMusic() {
            if (isMusicEnabled) {
                playBackgroundMusic();
            } else {
                stopBackgroundMusic();
            }
        }

        // Function to resume the game after a Revive
        function resumeGameAfterRevive() {
    // If there is a Play overlay (after revive), remove it
    const reviveOverlay = document.getElementById('revive-play-overlay');
    if (reviveOverlay) reviveOverlay.remove();
            console.log("Resuming game after revive with score: " + score);
            
            // Hide the game over screen
            hideGameOver();
            
            // Cancel the previous animation frame to avoid duplicates
            if (window.gameLoopAnimationId) {
                cancelAnimationFrame(window.gameLoopAnimationId);
                window.gameLoopAnimationId = null;
            }
            
            // Clear the canvas completely to avoid visual artifacts
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Reset game state - clear completely the arrays to avoid memory leaks
            squares.length = 0;
            fadingSquares.length = 0;
            particles.length = 0;
            
            // Reset game over animation variables
            gameOverAnimation = false;
            gameOverAnimationComplete = false;
            
            // Keep the current score (do not reset)
            
            // Update game mode
            gameMode = 'game';
            
            // Reset ball position and speed
            ball.x = canvas.width / 2;
            ball.y = canvas.height * 0.5;
            ball.direction = Math.random() > 0.5 ? 1 : -1;
            ball.speed = canvas.width * 0.0008;
            
            // Reset line position
            line.x = (canvas.width - line.width) / 2;
            line.y = ball.y - ball.radius;
            
            // Reset spawn interval
            squareInterval = 1000; // Reset to initial spawn interval
            lastSquareTime = Date.now();
            
            // Hide profile button during gameplay
            document.getElementById("profile-button").style.display = 'none';
            
            // Manage background music for game mode
            manageBackgroundMusic();
            
            // Reset frame time to avoid jumps
            lastFrameTime = null;
            
            // Ensure the game loop is properly reset and running
            gameRunning = true;
            
            // Force a new start of the game loop
            window.gameLoopAnimationId = requestAnimationFrame(gameLoop);
            
            // Play sound effect
            playSound('success');
            
            console.log("Game resumed after revive with score: " + score);
        }
    </script>
    <!-- Leaderboard Page Integration -->
    <link rel="stylesheet" href="leaderboard.css">
    <div id="leaderboard-screen" style="display: none;">
        <!-- Header -->
        <div class="leaderboard-header">
            <div class="leaderboard-title-section">
                <div class="leaderboard-title" id="leaderboard-season-title">Season 1</div>
                <div class="leaderboard-countdown">
                    <span class="countdown-label">ENDS IN :</span>
                    <span class="countdown-value" id="leaderboard-countdown-days">00</span><span class="countdown-unit">D</span>
                    <span class="countdown-sep">:</span>
                    <span class="countdown-value" id="leaderboard-countdown-hours">00</span><span class="countdown-unit">H</span>
                    <span class="countdown-sep">:</span>
                    <span class="countdown-value" id="leaderboard-countdown-minutes">00</span><span class="countdown-unit">M</span>
                </div>
            </div>
            <div class="close-button" id="close-leaderboard">
                <span class="close-icon">✕</span>
            </div>
        </div>
        <!-- Podium Top 3 -->
        <div class="leaderboard-podium">
            <div class="podium-second" id="podium-2">
                <div class="podium-avatar"><img id="podium-2-avatar" src="avatars/avatar_default.jpg" alt="User2"></div>
                <div class="podium-username" id="podium-2-username">-</div>
                <div class="podium-rank">2</div>
                <div class="podium-prize" id="podium-2-prize">-</div>
            </div>
            <div class="podium-first" id="podium-1">
                <div class="podium-avatar"><img id="podium-1-avatar" src="avatars/avatar_default.jpg" alt="User1"></div>
                <div class="podium-username" id="podium-1-username">-</div>
                <div class="podium-rank">1</div>
                <div class="podium-prize" id="podium-1-prize">-</div>
            </div>
            <div class="podium-third" id="podium-3">
                <div class="podium-avatar"><img id="podium-3-avatar" src="avatars/avatar_default.jpg" alt="User3"></div>
                <div class="podium-username" id="podium-3-username">-</div>
                <div class="podium-rank">3</div>
                <div class="podium-prize" id="podium-3-prize">-</div>
            </div>
        </div>
        <!-- Full Ranking List (Scrollable Group) -->
        <div class="leaderboard-scroll-group">
            <div class="leaderboard-list-container" style="position:relative;">
    <!-- Loading Overlay -->
    <div class="leaderboard-loading-overlay" id="leaderboard-loading-overlay" style="position:absolute;top:0;left:0;width:100%;height:100%;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.7);z-index:10;">
      <div style="display:flex;flex-direction:column;align-items:center;justify-content:center;">
        <img src="ressources/Dual Ball@1x-1.0s-200px-200px.svg" alt="Loading..." style="width:80px;height:80px;" />
        <div class="leaderboard-loading-bar-container">
          <div class="leaderboard-loading-bar"></div>
        </div>
      </div>
    </div>
    <div class="leaderboard-list" id="leaderboard-list">
        <!-- Ranking rows will be injected here -->
    </div>
</div>
        </div>
        <!-- Current User Ranking (Sticky Bottom) -->
        <div class="leaderboard-user-row" id="leaderboard-user-row">
            <!-- User's own ranking will be injected here -->
        </div>
    </div>
    <script src="leaderboard.js"></script>
    <!-- Sticky user row for Game Over page -->
    <script src="gameover-sticky.js"></script>
    <script src="gameover-promo.js"></script>
    <script src="season-dynamic.js"></script>
    <script>
      // Ensure leaderboard opens when clicking the season container
      document.addEventListener('DOMContentLoaded', function() {
        var seasonInfoContainer = document.getElementById('season-info-container');
        if (seasonInfoContainer) {
          seasonInfoContainer.addEventListener('click', function() {
            // Show the leaderboard when the user clicks on the season container
            if (typeof showLeaderboard === 'function') {
              showLeaderboard();
            }
          });
        }
        
        // Add a basic event handler for the leaderboard close button
        var closeLeaderboardBtn = document.getElementById('close-leaderboard');
        if (closeLeaderboardBtn) {
          closeLeaderboardBtn.addEventListener('click', function() {
            // Use the hideLeaderboard function if available, otherwise simply hide the screen
            if (typeof hideLeaderboard === 'function') {
              hideLeaderboard();
            } else {
              document.getElementById('leaderboard-screen').style.display = 'none';
            }
          });
        }
        
        // Help button logic
        var helpBtn = document.getElementById('help-button');
        if (helpBtn) {
          helpBtn.addEventListener('click', function() {
            fetch('/api/how-to-play-link').then(r => r.json()).then(data => {
              if (data && data.url && /^https:\/\/(www\.)?youtube\.com\//.test(data.url)) {
                // Try to open externally via Telegram WebApp API if available
                if (window.Telegram && Telegram.WebApp && Telegram.WebApp.openLink) {
                  Telegram.WebApp.openLink(data.url);
                } else {
                  window.open(data.url, '_blank');
                }
              } else {
                // Show notification (fallback)
                alert('No help video link has been set yet!');
              }
            }).catch(() => {
              alert('Failed to fetch help link');
            });
          });
        }
      });
    </script>
<script src="scoretotal-update.js"></script>
<div id="scoretotal-overlay" style="display:none;"></div>
<script src="scoretotal-overlay.js"></script>
</body>
</html>
